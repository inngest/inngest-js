## API Report File for "inngest"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { IfNever } from 'type-fest';
import { IsEqual } from 'type-fest';
import { IsUnknown } from 'type-fest';
import { Jsonify } from 'type-fest';
import { Simplify } from 'type-fest';
import { SimplifyDeep } from 'type-fest/source/merge-deep';
import { z } from 'zod';

// @public
export interface ClientOptions {
    baseUrl?: string;
    env?: string;
    eventKey?: string;
    fetch?: typeof fetch;
    id: string;
    // Warning: (ae-forgotten-export) The symbol "Logger" needs to be exported by the entry point index.d.ts
    logger?: Logger;
    // (undocumented)
    middleware?: InngestMiddleware.Stack;
    schemas?: EventSchemas<Record<string, EventPayload>>;
}

// @public
export type ClientOptionsFromInngest<TInngest extends Inngest<any>> = TInngest extends Inngest<infer U> ? U : ClientOptions;

// Warning: (ae-incompatible-release-tags) The symbol "Combine" is marked as @public, but its signature references "IsStringLiteral" which is marked as @internal
//
// @public
export type Combine<TCurr extends Record<string, EventPayload>, TInc extends StandardEventSchemas> = IsStringLiteral<keyof TCurr & string> extends true ? Simplify<Omit<TCurr, keyof StandardEventSchemaToPayload<TInc>> & StandardEventSchemaToPayload<TInc>> : StandardEventSchemaToPayload<TInc>;

// Warning: (ae-forgotten-export) The symbol "TriggersFromClient" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "BaseContext" needs to be exported by the entry point index.d.ts
// Warning: (ae-internal-missing-underscore) The name "Context" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export type Context<TClient extends Inngest.Any = Inngest.Any, TTriggers extends TriggersFromClient<TClient> = TriggersFromClient<TClient>, TOverrides extends Record<string, unknown> = Record<never, never>> = Omit<BaseContext<TClient, TTriggers>, keyof TOverrides> & TOverrides;

// @internal
export namespace Context {
    export type Any = Context;
}

// @public
export type EventNameFromTrigger<Events extends Record<string, EventPayload>, T extends InngestFunction.Trigger<keyof Events & string>> = T extends string ? T : T extends {
    event: string;
} ? T["event"] : string;

// Warning: (ae-forgotten-export) The symbol "MinimalEventPayload" needs to be exported by the entry point index.d.ts
//
// @public
export interface EventPayload<TData = any> extends MinimalEventPayload<TData> {
    name: string;
    ts?: number;
}

// @public
export class EventSchemas<S extends Record<string, EventPayload> = {
    [FnFailedEventName]: FailureEventPayload;
    [FnFinishedEventName]: FinishedEventPayload;
    [FnInvokedEventName]: InvokedEventPayload;
}> {
    fromGenerated<T extends StandardEventSchemas>(): EventSchemas<Combine<S, T>>;
    // Warning: (ae-forgotten-export) The symbol "PreventClashingNames" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "ClashingNameError" needs to be exported by the entry point index.d.ts
    fromRecord<T extends StandardEventSchemas>(..._args: PreventClashingNames<T> extends ClashingNameError ? [ClashingNameError] : []): EventSchemas<Combine<S, T>>;
    // Warning: (ae-forgotten-export) The symbol "StandardEventSchema" needs to be exported by the entry point index.d.ts
    fromUnion<T extends {
        name: string;
    } & StandardEventSchema>(): EventSchemas<Combine<S, { [K in T["name"]]: Extract<T, {
            name: K;
        }>; }>>;
    // Warning: (ae-forgotten-export) The symbol "LiteralZodEventSchemas" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "ZodToStandardSchema" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "PickLiterals" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "GetName" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "InferZodShape" needs to be exported by the entry point index.d.ts
    fromZod<T extends ZodEventSchemas | LiteralZodEventSchemas>(schemas: T): EventSchemas<Combine<S, ZodToStandardSchema<T extends ZodEventSchemas ? T : PickLiterals<T extends LiteralZodEventSchemas ? { [I in keyof T as GetName<T[I]>]: InferZodShape<T[I]>; } : T extends ZodEventSchemas ? T : never>>>>;
}

// @public
export type EventsFromOpts<TOpts extends ClientOptions> = TOpts["schemas"] extends EventSchemas<infer U> ? U : Record<string, EventPayload>;

// @public
export type FailureEventArgs<P extends EventPayload = EventPayload> = {
    event: FailureEventPayload<P>;
    error: Error;
};

// @public
export type FailureEventPayload<P extends EventPayload = EventPayload> = {
    name: `${internalEvents.FunctionFailed}`;
    data: {
        function_id: string;
        run_id: string;
        error: z.output<typeof failureEventErrorSchema>;
        event: P;
    };
};

// @public
export type FinishedEventPayload = {
    name: `${internalEvents.FunctionFinished}`;
    data: {
        function_id: string;
        run_id: string;
        correlation_id?: string;
    } & ({
        error: z.output<typeof failureEventErrorSchema>;
    } | {
        result: unknown;
    });
};

// @public
export interface FunctionOptions<TClient extends Inngest.Any, TEvents extends GetEvents<TClient, true>, TEvent extends TriggersFromClient<TClient>[number], TMiddleware extends InngestMiddleware.Stack, TFailureHandler extends Handler.Any> {
    batchEvents?: {
        maxSize: number;
        timeout: TimeStrBatch;
    };
    // Warning: (ae-forgotten-export) The symbol "Cancellation" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    cancelOn?: Cancellation<TEvents, TEvent>[];
    // Warning: (ae-forgotten-export) The symbol "ConcurrencyOption" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "RecursiveTuple" needs to be exported by the entry point index.d.ts
    concurrency?: number | ConcurrencyOption | RecursiveTuple<ConcurrencyOption, 2>;
    debounce?: {
        key?: string;
        period: TimeStr;
        timeout?: TimeStr;
    };
    id: string;
    idempotency?: string;
    middleware?: TMiddleware;
    name?: string;
    // (undocumented)
    onFailure?: TFailureHandler;
    priority?: {
        run?: string;
    };
    rateLimit?: {
        key?: string;
        limit: number;
        period: TimeStr;
    };
    retries?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20;
}

// @public
export type GetEvents<TInngest extends Inngest.Any, TWithInternal extends boolean = false> = TWithInternal extends true ? EventsFromOpts<ClientOptionsFromInngest<TInngest>> : WithoutInternal<EventsFromOpts<ClientOptionsFromInngest<TInngest>>>;

// Warning: (ae-forgotten-export) The symbol "ExtendWithMiddleware" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "builtInMiddleware" needs to be exported by the entry point index.d.ts
//
// @public
export type GetFunctionInput<TClient extends Inngest.Any, TTrigger extends TriggersFromClient<TClient>[number] | TriggersFromClient<TClient>[number][] = TriggersFromClient<TClient>[number]> = Parameters<Handler<TClient, TTrigger extends string ? [TTrigger] : TTrigger, ExtendWithMiddleware<[
typeof builtInMiddleware,
NonNullable<ClientOptionsFromInngest<TClient>["middleware"]>
]>>>[0];

// Warning: (ae-forgotten-export) The symbol "InvokeTargetFunctionDefinition" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "GetFunctionOutputFromInngestFunction" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "GetFunctionOutputFromReferenceInngestFunction" needs to be exported by the entry point index.d.ts
//
// @public
export type GetFunctionOutput<TFunction extends InvokeTargetFunctionDefinition> = TFunction extends InngestFunction.Any ? GetFunctionOutputFromInngestFunction<TFunction> : TFunction extends InngestFunctionReference.Any ? GetFunctionOutputFromReferenceInngestFunction<TFunction> : unknown;

// @public
export type GetStepTools<TInngest extends Inngest<any>, TTrigger extends keyof GetEvents<TInngest> & string = keyof GetEvents<TInngest> & string> = GetFunctionInput<TInngest, TTrigger> extends {
    step: infer TStep;
} ? TStep : never;

// Warning: (ae-incompatible-release-tags) The symbol "Handler" is marked as @public, but its signature references "Context" which is marked as @internal
//
// @public
export type Handler<TClient extends Inngest.Any, TTriggers extends TriggersFromClient<TClient> = TriggersFromClient<TClient>, TOverrides extends Record<string, unknown> = Record<never, never>> = (
ctx: Context<TClient, TTriggers, TOverrides>) => unknown;

// @public
export namespace Handler {
    export type Any = Handler<any, any, any>;
}

// @public
export enum headerKeys {
    // (undocumented)
    Environment = "x-inngest-env",
    // (undocumented)
    Framework = "x-inngest-framework",
    // (undocumented)
    InngestExpectedServerKind = "x-inngest-expected-server-kind",
    // (undocumented)
    InngestServerKind = "x-inngest-server-kind",
    // (undocumented)
    NoRetry = "x-inngest-no-retry",
    // (undocumented)
    Platform = "x-inngest-platform",
    // (undocumented)
    RequestVersion = "x-inngest-req-version",
    // (undocumented)
    RetryAfter = "retry-after",
    // (undocumented)
    SdkVersion = "x-inngest-sdk",
    // (undocumented)
    Signature = "x-inngest-signature"
}

// @public
export class Inngest<TClientOpts extends ClientOptions = ClientOptions> {
    constructor({ id, eventKey, baseUrl, fetch, env, logger, middleware, }: TClientOpts);
    // (undocumented)
    createFunction<TFnOpts extends FunctionOptions<this, GetEvents<this, true>, TTriggerName, TMiddleware, TFailureHandler>, TMiddleware extends InngestMiddleware.Stack, TTrigger extends TriggerOptions<TTriggerName>, TTriggerName extends TriggersFromClient<this>[number] = EventNameFromTrigger<GetEvents<this, true>, TTrigger>, THandler extends Handler.Any = Handler<this, [
    TTriggerName
    ], ExtendWithMiddleware<[
    typeof builtInMiddleware,
    NonNullable<TClientOpts["middleware"]>,
    TMiddleware
    ]>>, TFailureHandler extends Handler.Any = Handler<this, [
    TTriggerName
    ], ExtendWithMiddleware<[
    typeof builtInMiddleware,
    NonNullable<ClientOptionsFromInngest<this>["middleware"]>,
    TMiddleware
    ], FailureEventArgs<GetEvents<this, true>[TTriggerName]>>>>(options: TFnOpts, trigger: TTrigger, handler: THandler): InngestFunction<InngestFunction.OptionsWithTrigger<this, TMiddleware, [
    TTrigger
    ], TFailureHandler>, THandler, this, TMiddleware, [
    TTrigger
    ]>;
    readonly id: string;
    // Warning: (ae-forgotten-export) The symbol "SendEventPayload" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "SendEventOutput" needs to be exported by the entry point index.d.ts
    send<Payload extends SendEventPayload<GetEvents<this>>>(payload: Payload): Promise<SendEventOutput<TClientOpts>>;
    setEventKey(
    eventKey: string): void;
}

// @public
export namespace Inngest {
    export type Any = Inngest;
}

// @public
export class InngestCommHandler<Input extends any[] = any[], Output = any, StreamOutput = any> {
    // Warning: (ae-forgotten-export) The symbol "InngestCommHandlerOptions" needs to be exported by the entry point index.d.ts
    constructor(options: InngestCommHandlerOptions<Input, Output, StreamOutput>);
    // Warning: (ae-forgotten-export) The symbol "FunctionConfig" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    protected configs(url: URL): FunctionConfig[];
    createHandler(): (...args: Input) => Promise<Awaited<Output>>;
    protected readonly frameworkName: string;
    // Warning: (ae-forgotten-export) The symbol "Handler_2" needs to be exported by the entry point index.d.ts
    readonly handler: Handler_2;
    readonly id: string;
    protected _isProd: boolean;
    protected log(level: LogLevel, ...args: unknown[]): void;
    protected readonly logLevel: LogLevel;
    // (undocumented)
    protected register(url: URL, deployId: string | undefined | null, getHeaders: () => Record<string, string>): Promise<{
        status: number;
        message: string;
        modified: boolean;
    }>;
    // Warning: (ae-forgotten-export) The symbol "RegisterRequest" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    protected registerBody(url: URL): RegisterRequest;
    protected reqUrl(url: URL): URL;
    // (undocumented)
    protected runStep({ functionId, stepId, data, timer, reqArgs, }: {
        functionId: string;
        stepId: string | null;
        data: unknown;
        timer: ServerTiming;
        reqArgs: unknown[];
    }): {
        version: ExecutionVersion;
        result: Promise<ExecutionResult>;
    };
    protected readonly serveHost: string | undefined;
    protected readonly servePath: string | undefined;
    protected signingKey: string | undefined;
    // (undocumented)
    protected signResponse(): string;
    protected _skipDevServer: boolean;
    // (undocumented)
    protected readonly streaming: RegisterOptions["streaming"];
    // (undocumented)
    protected validateSignature(sig: string | undefined, body: unknown): void;
}

// @public
export class InngestFunction<TFnOpts extends InngestFunction.OptionsWithTrigger<TClient, TMiddleware, TTriggers>, THandler extends Handler.Any, // todo make this specific
TClient extends Inngest.Any = Inngest.Any, TMiddleware extends InngestMiddleware.Stack = InngestMiddleware.Stack, TTriggers extends InngestFunction.Trigger<TriggersFromClient<TClient>[number]>[] = InngestFunction.Trigger<TriggersFromClient<TClient>[number]>[]> {
    constructor(client: TClient,
    opts: TFnOpts, fn: THandler);
    // (undocumented)
    static failureSuffix: string;
    id(prefix?: string): string;
    get name(): string;
    // (undocumented)
    readonly opts: TFnOpts;
    // (undocumented)
    static stepId: string;
}

// @public
export namespace InngestFunction {
    export type Any = InngestFunction<any, Handler.Any, any, any, any>;
    export interface OptionsWithTrigger<TClient extends Inngest.Any = Inngest.Any, TMiddleware extends InngestMiddleware.Stack = InngestMiddleware.Stack, TTriggers extends InngestFunction.Trigger<TriggersFromClient<TClient>[number]>[] = InngestFunction.Trigger<TriggersFromClient<TClient>[number]>[], TFailureHandler extends Handler.Any = Handler.Any> {
        batchEvents?: {
            maxSize: number;
            timeout: TimeStrBatch;
        };
        // (undocumented)
        cancelOn?: Cancellation<GetEvents<TClient, true>, EventNameFromTrigger<GetEvents<TClient, true>, TTriggers[number]>>[];
        concurrency?: number | ConcurrencyOption | RecursiveTuple<ConcurrencyOption, 2>;
        debounce?: {
            key?: string;
            period: TimeStr;
            timeout?: TimeStr;
        };
        id: string;
        idempotency?: string;
        middleware?: TMiddleware;
        name?: string;
        onFailure?: TFailureHandler;
        priority?: {
            run?: string;
        };
        rateLimit?: {
            key?: string;
            limit: number;
            period: TimeStr;
        };
        retries?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20;
        // (undocumented)
        triggers?: TTriggers;
    }
    export type Trigger<T extends string> = StrictUnion<{
        event: T;
        if?: string;
    } | {
        cron: string;
    }>;
}

// @public
export class InngestFunctionReference<
/**
* The payload expected by the referenced function.
*
* Must be in the shape of an event payload.
*/
_TInput extends MinimalEventPayload,
/**
* The output of the referenced function.
*/
_TOutput> {
    constructor(opts: {
        functionId: string;
        appId?: string;
    });
    // (undocumented)
    readonly opts: {
        functionId: string;
        appId?: string;
    };
}

// @public
export namespace InngestFunctionReference {
    export type Any = InngestFunctionReference<MinimalEventPayload, any>;
    export type HelperArgs<TFnInput, TFnOutput> = {
        functionId: string;
        appId?: string;
        schemas?: {
            data?: TFnInput;
            return?: TFnOutput;
        };
    };
    export type HelperGenericArgs<TFnInput, TFnOutput> = HelperArgs<TFnInput, TFnOutput> | InngestFunction.Any;
    // Warning: (ae-forgotten-export) The symbol "PayloadFromAnyInngestFunction" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "IsAny" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "ResolveSchema" needs to be exported by the entry point index.d.ts
    export type HelperReturn<TArgs> = TArgs extends InngestFunction.Any ? InngestFunctionReference<PayloadFromAnyInngestFunction<TArgs>, GetFunctionOutput<TArgs>> : TArgs extends HelperArgs<infer TFnInput, infer TFnOutput> ? InngestFunctionReference<IsAny<ResolveSchema<TFnInput, TFnInput, any>> extends true ? MinimalEventPayload : Simplify<MinimalEventPayload<ResolveSchema<TFnInput, TFnInput, any>> & Required<Pick<MinimalEventPayload<ResolveSchema<TFnInput, TFnInput, any>>, "data">>>, ResolveSchema<TFnOutput, TFnOutput, unknown>> : never;
}

// @public
export class InngestMiddleware<TOpts extends MiddlewareOptions> {
    constructor({ name, init }: TOpts);
    readonly init: TOpts["init"];
    readonly name: TOpts["name"];
}

// @public (undocumented)
export namespace InngestMiddleware {
    // (undocumented)
    export type Stack = [
    InngestMiddleware<MiddlewareOptions>,
    ...InngestMiddleware<MiddlewareOptions>[]
    ];
}

// @public
export enum internalEvents {
    FunctionFailed = "inngest/function.failed",
    // (undocumented)
    FunctionFinished = "inngest/function.finished",
    // (undocumented)
    FunctionInvoked = "inngest/function.invoked"
}

// Warning: (ae-internal-missing-underscore) The name "IsStringLiteral" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export type IsStringLiteral<T extends string> = string extends T ? false : true;

// Warning: (ae-forgotten-export) The symbol "z_2" needs to be exported by the entry point index.d.ts
//
// @public
export type LiteralZodEventSchema = z_2.ZodObject<{
    name: z_2.ZodLiteral<string>;
    data?: z_2.ValidZodValue;
    user?: z_2.ValidZodValue;
}>;

// @public
export type LogArg = unknown;

// Warning: (ae-forgotten-export) The symbol "logLevels" needs to be exported by the entry point index.d.ts
//
// @public
export type LogLevel = (typeof logLevels)[number];

// @public
export interface MiddlewareOptions {
    init: MiddlewareRegisterFn;
    name: string;
}

// Warning: (ae-forgotten-export) The symbol "MaybePromise" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type MiddlewareRegisterFn = (ctx: {
    client: Inngest.Any;
    fn?: InngestFunction.Any;
}) => MaybePromise<MiddlewareRegisterReturn>;

// @public (undocumented)
export type MiddlewareRegisterReturn = {
    onFunctionRun?: (ctx: InitialRunInfo) => MaybePromise<{
        transformInput?: MiddlewareRunInput;
        beforeMemoization?: BlankHook;
        afterMemoization?: BlankHook;
        beforeExecution?: BlankHook;
        afterExecution?: BlankHook;
        transformOutput?: MiddlewareRunOutput;
        beforeResponse?: BlankHook;
    }>;
    onSendEvent?: () => MaybePromise<{
        transformInput?: MiddlewareSendEventInput;
        transformOutput?: MiddlewareSendEventOutput;
    }>;
};

// @public
export class NonRetriableError extends Error {
    constructor(message: string, options?: {
        cause?: unknown;
    });
    readonly cause?: unknown;
}

// @public
export class ProxyLogger implements Logger {
    constructor(logger: Logger);
    // (undocumented)
    debug(...args: LogArg[]): void;
    // (undocumented)
    disable(): void;
    // (undocumented)
    enable(): void;
    // (undocumented)
    error(...args: LogArg[]): void;
    // (undocumented)
    flush(): Promise<void>;
    // (undocumented)
    info(...args: LogArg[]): void;
    // (undocumented)
    warn(...args: LogArg[]): void;
}

// @public
export enum queryKeys {
    // (undocumented)
    DeployId = "deployId",
    // (undocumented)
    FnId = "fnId",
    // (undocumented)
    StepId = "stepId"
}

// Warning: (ae-forgotten-export) The symbol "ValidZodValue" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "ZodTypeAny" needs to be exported by the entry point index.d.ts
//
// @public
export const referenceFunction: <TArgs extends InngestFunctionReference.HelperGenericArgs<TFnInput, TFnOutput>, TFnInput extends ValidZodValue = ValidZodValue, TFnOutput extends ZodTypeAny = ZodTypeAny>({ functionId, appId, }: TArgs extends InngestFunction.Any ? Omit<InngestFunctionReference.HelperArgs<any, any>, "schemas"> : TArgs) => InngestFunctionReference.HelperReturn<TArgs>;

// @public
export interface RegisterOptions {
    baseUrl?: string;
    fetch?: typeof fetch;
    id?: string;
    logLevel?: LogLevel;
    serveHost?: string;
    servePath?: string;
    signingKey?: string;
    streaming?: "allow" | "force" | false;
}

// @public
export class RetryAfterError extends Error {
    constructor(message: string,
    retryAfter: number | string | Date, options?: {
        cause?: unknown;
    });
    readonly cause?: unknown;
    readonly retryAfter: string;
}

// @public
export interface ServeHandlerOptions extends RegisterOptions {
    client: Inngest.Any;
    functions: readonly InngestFunction.Any[];
}

// @public
export const slugify: (str: string) => string;

// @public
export type StandardEventSchemas = Record<string, StandardEventSchema>;

// @public
export type StandardEventSchemaToPayload<T> = Simplify<{
    [K in keyof T & string]: {
        [K2 in keyof (Omit<EventPayload, keyof T[K]> & T[K] & {
            name: K;
        })]: (Omit<EventPayload, keyof T[K]> & T[K] & {
            name: K;
        })[K2];
    };
}>;

// @public
export class StepError extends Error {
    constructor(
    stepId: string, err: unknown);
    readonly stepId: string;
}

// @public
export interface StepOptions {
    id: string;
    name?: string;
}

// @public
export type StepOptionsOrId = StepOptions["id"] | StepOptions;

// @public
export type StrictUnion<T> = StrictUnionHelper<T, T>;

// @public
export type StrictUnionHelper<T, TAll> = T extends any ? T & Partial<Record<Exclude<UnionKeys<TAll>, keyof T>, never>> : never;

// @public
export type TimeStr = `${`${number}w` | ""}${`${number}d` | ""}${`${number}h` | ""}${`${number}m` | ""}${`${number}s` | ""}`;

// @public
export type TriggerOptions<T extends string> = StrictUnion<{
    event: T;
    if?: string;
} | {
    cron: string;
} | null>;

// @public
export type UnionKeys<T> = T extends T ? keyof T : never;

// @public (undocumented)
export type WithoutInternal<T extends Record<string, EventPayload>> = {
    [K in keyof T as K extends `inngest/${string}` ? never : K]: T[K];
};

// @public
export type ZodEventSchemas = Record<string, {
    data?: z_2.ValidZodValue;
    user?: z_2.ValidZodValue;
}>;

// Warnings were encountered during analysis:
//
// src/components/EventSchemas.ts:225:5 - (ae-forgotten-export) The symbol "FnFailedEventName" needs to be exported by the entry point index.d.ts
// src/components/EventSchemas.ts:226:5 - (ae-forgotten-export) The symbol "FnFinishedEventName" needs to be exported by the entry point index.d.ts
// src/components/EventSchemas.ts:227:5 - (ae-forgotten-export) The symbol "FnInvokedEventName" needs to be exported by the entry point index.d.ts
// src/components/EventSchemas.ts:227:5 - (ae-forgotten-export) The symbol "InvokedEventPayload" needs to be exported by the entry point index.d.ts
// src/components/InngestCommHandler.ts:903:5 - (ae-forgotten-export) The symbol "ServerTiming" needs to be exported by the entry point index.d.ts
// src/components/InngestCommHandler.ts:905:9 - (ae-forgotten-export) The symbol "ExecutionVersion" needs to be exported by the entry point index.d.ts
// src/components/InngestCommHandler.ts:905:36 - (ae-forgotten-export) The symbol "ExecutionResult" needs to be exported by the entry point index.d.ts
// src/components/InngestMiddleware.ts:274:3 - (ae-forgotten-export) The symbol "InitialRunInfo" needs to be exported by the entry point index.d.ts
// src/components/InngestMiddleware.ts:287:5 - (ae-forgotten-export) The symbol "MiddlewareRunInput" needs to be exported by the entry point index.d.ts
// src/components/InngestMiddleware.ts:293:5 - (ae-forgotten-export) The symbol "BlankHook" needs to be exported by the entry point index.d.ts
// src/components/InngestMiddleware.ts:326:5 - (ae-forgotten-export) The symbol "MiddlewareRunOutput" needs to be exported by the entry point index.d.ts
// src/components/InngestMiddleware.ts:345:5 - (ae-forgotten-export) The symbol "MiddlewareSendEventInput" needs to be exported by the entry point index.d.ts
// src/components/InngestMiddleware.ts:352:5 - (ae-forgotten-export) The symbol "MiddlewareSendEventOutput" needs to be exported by the entry point index.d.ts
// src/types.ts:52:5 - (ae-forgotten-export) The symbol "failureEventErrorSchema" needs to be exported by the entry point index.d.ts
// src/types.ts:836:5 - (ae-forgotten-export) The symbol "TimeStrBatch" needs to be exported by the entry point index.d.ts

// (No @packageDocumentation comment for this package)

```
