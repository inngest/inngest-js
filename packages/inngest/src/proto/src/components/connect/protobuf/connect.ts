// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               v5.29.3
// source: src/components/connect/protobuf/connect.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Timestamp } from "../../../../google/protobuf/timestamp";

export const protobufPackage = "connect.v1";

export enum GatewayMessageType {
  GATEWAY_HELLO = 0,
  WORKER_CONNECT = 1,
  GATEWAY_CONNECTION_READY = 2,
  GATEWAY_EXECUTOR_REQUEST = 3,
  WORKER_READY = 4,
  WORKER_REQUEST_ACK = 5,
  WORKER_REPLY = 6,
  WORKER_REPLY_ACK = 7,
  WORKER_PAUSE = 8,
  WORKER_HEARTBEAT = 9,
  GATEWAY_HEARTBEAT = 10,
  GATEWAY_CLOSING = 11,
  UNRECOGNIZED = -1,
}

export function gatewayMessageTypeFromJSON(object: any): GatewayMessageType {
  switch (object) {
    case 0:
    case "GATEWAY_HELLO":
      return GatewayMessageType.GATEWAY_HELLO;
    case 1:
    case "WORKER_CONNECT":
      return GatewayMessageType.WORKER_CONNECT;
    case 2:
    case "GATEWAY_CONNECTION_READY":
      return GatewayMessageType.GATEWAY_CONNECTION_READY;
    case 3:
    case "GATEWAY_EXECUTOR_REQUEST":
      return GatewayMessageType.GATEWAY_EXECUTOR_REQUEST;
    case 4:
    case "WORKER_READY":
      return GatewayMessageType.WORKER_READY;
    case 5:
    case "WORKER_REQUEST_ACK":
      return GatewayMessageType.WORKER_REQUEST_ACK;
    case 6:
    case "WORKER_REPLY":
      return GatewayMessageType.WORKER_REPLY;
    case 7:
    case "WORKER_REPLY_ACK":
      return GatewayMessageType.WORKER_REPLY_ACK;
    case 8:
    case "WORKER_PAUSE":
      return GatewayMessageType.WORKER_PAUSE;
    case 9:
    case "WORKER_HEARTBEAT":
      return GatewayMessageType.WORKER_HEARTBEAT;
    case 10:
    case "GATEWAY_HEARTBEAT":
      return GatewayMessageType.GATEWAY_HEARTBEAT;
    case 11:
    case "GATEWAY_CLOSING":
      return GatewayMessageType.GATEWAY_CLOSING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GatewayMessageType.UNRECOGNIZED;
  }
}

export function gatewayMessageTypeToJSON(object: GatewayMessageType): string {
  switch (object) {
    case GatewayMessageType.GATEWAY_HELLO:
      return "GATEWAY_HELLO";
    case GatewayMessageType.WORKER_CONNECT:
      return "WORKER_CONNECT";
    case GatewayMessageType.GATEWAY_CONNECTION_READY:
      return "GATEWAY_CONNECTION_READY";
    case GatewayMessageType.GATEWAY_EXECUTOR_REQUEST:
      return "GATEWAY_EXECUTOR_REQUEST";
    case GatewayMessageType.WORKER_READY:
      return "WORKER_READY";
    case GatewayMessageType.WORKER_REQUEST_ACK:
      return "WORKER_REQUEST_ACK";
    case GatewayMessageType.WORKER_REPLY:
      return "WORKER_REPLY";
    case GatewayMessageType.WORKER_REPLY_ACK:
      return "WORKER_REPLY_ACK";
    case GatewayMessageType.WORKER_PAUSE:
      return "WORKER_PAUSE";
    case GatewayMessageType.WORKER_HEARTBEAT:
      return "WORKER_HEARTBEAT";
    case GatewayMessageType.GATEWAY_HEARTBEAT:
      return "GATEWAY_HEARTBEAT";
    case GatewayMessageType.GATEWAY_CLOSING:
      return "GATEWAY_CLOSING";
    case GatewayMessageType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum SDKResponseStatus {
  NOT_COMPLETED = 0,
  DONE = 1,
  ERROR = 2,
  UNRECOGNIZED = -1,
}

export function sDKResponseStatusFromJSON(object: any): SDKResponseStatus {
  switch (object) {
    case 0:
    case "NOT_COMPLETED":
      return SDKResponseStatus.NOT_COMPLETED;
    case 1:
    case "DONE":
      return SDKResponseStatus.DONE;
    case 2:
    case "ERROR":
      return SDKResponseStatus.ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SDKResponseStatus.UNRECOGNIZED;
  }
}

export function sDKResponseStatusToJSON(object: SDKResponseStatus): string {
  switch (object) {
    case SDKResponseStatus.NOT_COMPLETED:
      return "NOT_COMPLETED";
    case SDKResponseStatus.DONE:
      return "DONE";
    case SDKResponseStatus.ERROR:
      return "ERROR";
    case SDKResponseStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ConnectionStatus {
  CONNECTED = 0,
  READY = 1,
  DRAINING = 2,
  DISCONNECTING = 3,
  DISCONNECTED = 4,
  UNRECOGNIZED = -1,
}

export function connectionStatusFromJSON(object: any): ConnectionStatus {
  switch (object) {
    case 0:
    case "CONNECTED":
      return ConnectionStatus.CONNECTED;
    case 1:
    case "READY":
      return ConnectionStatus.READY;
    case 2:
    case "DRAINING":
      return ConnectionStatus.DRAINING;
    case 3:
    case "DISCONNECTING":
      return ConnectionStatus.DISCONNECTING;
    case 4:
    case "DISCONNECTED":
      return ConnectionStatus.DISCONNECTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ConnectionStatus.UNRECOGNIZED;
  }
}

export function connectionStatusToJSON(object: ConnectionStatus): string {
  switch (object) {
    case ConnectionStatus.CONNECTED:
      return "CONNECTED";
    case ConnectionStatus.READY:
      return "READY";
    case ConnectionStatus.DRAINING:
      return "DRAINING";
    case ConnectionStatus.DISCONNECTING:
      return "DISCONNECTING";
    case ConnectionStatus.DISCONNECTED:
      return "DISCONNECTED";
    case ConnectionStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum WorkerDisconnectReason {
  WORKER_SHUTDOWN = 0,
  UNRECOGNIZED = -1,
}

export function workerDisconnectReasonFromJSON(object: any): WorkerDisconnectReason {
  switch (object) {
    case 0:
    case "WORKER_SHUTDOWN":
      return WorkerDisconnectReason.WORKER_SHUTDOWN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WorkerDisconnectReason.UNRECOGNIZED;
  }
}

export function workerDisconnectReasonToJSON(object: WorkerDisconnectReason): string {
  switch (object) {
    case WorkerDisconnectReason.WORKER_SHUTDOWN:
      return "WORKER_SHUTDOWN";
    case WorkerDisconnectReason.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface ConnectMessage {
  kind: GatewayMessageType;
  payload: Uint8Array;
}

export interface AppConfiguration {
  appName: string;
  appVersion?: string | undefined;
  functions: Uint8Array;
}

export interface AuthData {
  sessionToken: string;
  syncToken: string;
}

export interface WorkerConnectRequestData {
  connectionId: string;
  instanceId: string;
  authData: AuthData | undefined;
  capabilities: Uint8Array;
  apps: AppConfiguration[];
  workerManualReadinessAck: boolean;
  systemAttributes: SystemAttributes | undefined;
  environment?: string | undefined;
  framework: string;
  platform?: string | undefined;
  sdkVersion: string;
  sdkLanguage: string;
  startedAt: Date | undefined;
}

export interface GatewayExecutorRequestData {
  requestId: string;
  accountId: string;
  envId: string;
  appId: string;
  appName: string;
  functionId: string;
  functionSlug: string;
  stepId?: string | undefined;
  requestPayload: Uint8Array;
  systemTraceCtx: Uint8Array;
  userTraceCtx: Uint8Array;
}

export interface WorkerRequestAckData {
  requestId: string;
  accountId: string;
  envId: string;
  appId: string;
  functionSlug: string;
  stepId?: string | undefined;
  systemTraceCtx: Uint8Array;
  userTraceCtx: Uint8Array;
}

export interface SDKResponse {
  requestId: string;
  accountId: string;
  envId: string;
  appId: string;
  status: SDKResponseStatus;
  body: Uint8Array;
  noRetry: boolean;
  retryAfter?: string | undefined;
  sdkVersion: string;
  requestVersion: number;
  systemTraceCtx: Uint8Array;
  userTraceCtx: Uint8Array;
}

export interface WorkerReplyAckData {
  requestId: string;
}

/** Connection metadata */
export interface ConnMetadata {
  id: string;
  gatewayId: string;
  instanceId: string;
  workerGroups: { [key: string]: string };
  status: ConnectionStatus;
  lastHeartbeatAt: Date | undefined;
  sdkLanguage: string;
  sdkVersion: string;
  attributes: SystemAttributes | undefined;
}

export interface ConnMetadata_WorkerGroupsEntry {
  key: string;
  value: string;
}

export interface SystemAttributes {
  cpuCores: number;
  memBytes: number;
  os: string;
}

export interface ConnGroup {
  envId: string;
  appId: string;
  appName: string;
  hash: string;
  conns: ConnMetadata[];
  syncId?: string | undefined;
  appVersion?: string | undefined;
}

export interface StartResponse {
  connectionId: string;
  gatewayEndpoint: string;
  gatewayGroup: string;
  sessionToken: string;
  syncToken: string;
}

export interface StartRequest {
  excludeGateways: string[];
}

export interface FlushResponse {
  requestId: string;
}

export interface PubSubAckMessage {
  ts: Date | undefined;
  nack?: boolean | undefined;
  nackReason?: SystemError | undefined;
}

export interface SystemError {
  code: string;
  data?: Uint8Array | undefined;
  message: string;
}

function createBaseConnectMessage(): ConnectMessage {
  return { kind: 0, payload: new Uint8Array(0) };
}

export const ConnectMessage: MessageFns<ConnectMessage> = {
  encode(message: ConnectMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.kind !== 0) {
      writer.uint32(8).int32(message.kind);
    }
    if (message.payload.length !== 0) {
      writer.uint32(18).bytes(message.payload);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConnectMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnectMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.kind = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.payload = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConnectMessage {
    return {
      kind: isSet(object.kind) ? gatewayMessageTypeFromJSON(object.kind) : 0,
      payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(0),
    };
  },

  toJSON(message: ConnectMessage): unknown {
    const obj: any = {};
    if (message.kind !== 0) {
      obj.kind = gatewayMessageTypeToJSON(message.kind);
    }
    if (message.payload.length !== 0) {
      obj.payload = base64FromBytes(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConnectMessage>, I>>(base?: I): ConnectMessage {
    return ConnectMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConnectMessage>, I>>(object: I): ConnectMessage {
    const message = createBaseConnectMessage();
    message.kind = object.kind ?? 0;
    message.payload = object.payload ?? new Uint8Array(0);
    return message;
  },
};

function createBaseAppConfiguration(): AppConfiguration {
  return { appName: "", appVersion: undefined, functions: new Uint8Array(0) };
}

export const AppConfiguration: MessageFns<AppConfiguration> = {
  encode(message: AppConfiguration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.appName !== "") {
      writer.uint32(10).string(message.appName);
    }
    if (message.appVersion !== undefined) {
      writer.uint32(18).string(message.appVersion);
    }
    if (message.functions.length !== 0) {
      writer.uint32(34).bytes(message.functions);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AppConfiguration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppConfiguration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.appName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.appVersion = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.functions = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppConfiguration {
    return {
      appName: isSet(object.appName) ? globalThis.String(object.appName) : "",
      appVersion: isSet(object.appVersion) ? globalThis.String(object.appVersion) : undefined,
      functions: isSet(object.functions) ? bytesFromBase64(object.functions) : new Uint8Array(0),
    };
  },

  toJSON(message: AppConfiguration): unknown {
    const obj: any = {};
    if (message.appName !== "") {
      obj.appName = message.appName;
    }
    if (message.appVersion !== undefined) {
      obj.appVersion = message.appVersion;
    }
    if (message.functions.length !== 0) {
      obj.functions = base64FromBytes(message.functions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AppConfiguration>, I>>(base?: I): AppConfiguration {
    return AppConfiguration.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AppConfiguration>, I>>(object: I): AppConfiguration {
    const message = createBaseAppConfiguration();
    message.appName = object.appName ?? "";
    message.appVersion = object.appVersion ?? undefined;
    message.functions = object.functions ?? new Uint8Array(0);
    return message;
  },
};

function createBaseAuthData(): AuthData {
  return { sessionToken: "", syncToken: "" };
}

export const AuthData: MessageFns<AuthData> = {
  encode(message: AuthData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionToken !== "") {
      writer.uint32(10).string(message.sessionToken);
    }
    if (message.syncToken !== "") {
      writer.uint32(18).string(message.syncToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.syncToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthData {
    return {
      sessionToken: isSet(object.sessionToken) ? globalThis.String(object.sessionToken) : "",
      syncToken: isSet(object.syncToken) ? globalThis.String(object.syncToken) : "",
    };
  },

  toJSON(message: AuthData): unknown {
    const obj: any = {};
    if (message.sessionToken !== "") {
      obj.sessionToken = message.sessionToken;
    }
    if (message.syncToken !== "") {
      obj.syncToken = message.syncToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthData>, I>>(base?: I): AuthData {
    return AuthData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthData>, I>>(object: I): AuthData {
    const message = createBaseAuthData();
    message.sessionToken = object.sessionToken ?? "";
    message.syncToken = object.syncToken ?? "";
    return message;
  },
};

function createBaseWorkerConnectRequestData(): WorkerConnectRequestData {
  return {
    connectionId: "",
    instanceId: "",
    authData: undefined,
    capabilities: new Uint8Array(0),
    apps: [],
    workerManualReadinessAck: false,
    systemAttributes: undefined,
    environment: undefined,
    framework: "",
    platform: undefined,
    sdkVersion: "",
    sdkLanguage: "",
    startedAt: undefined,
  };
}

export const WorkerConnectRequestData: MessageFns<WorkerConnectRequestData> = {
  encode(message: WorkerConnectRequestData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.connectionId !== "") {
      writer.uint32(10).string(message.connectionId);
    }
    if (message.instanceId !== "") {
      writer.uint32(18).string(message.instanceId);
    }
    if (message.authData !== undefined) {
      AuthData.encode(message.authData, writer.uint32(26).fork()).join();
    }
    if (message.capabilities.length !== 0) {
      writer.uint32(34).bytes(message.capabilities);
    }
    for (const v of message.apps) {
      AppConfiguration.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.workerManualReadinessAck !== false) {
      writer.uint32(48).bool(message.workerManualReadinessAck);
    }
    if (message.systemAttributes !== undefined) {
      SystemAttributes.encode(message.systemAttributes, writer.uint32(58).fork()).join();
    }
    if (message.environment !== undefined) {
      writer.uint32(66).string(message.environment);
    }
    if (message.framework !== "") {
      writer.uint32(74).string(message.framework);
    }
    if (message.platform !== undefined) {
      writer.uint32(82).string(message.platform);
    }
    if (message.sdkVersion !== "") {
      writer.uint32(90).string(message.sdkVersion);
    }
    if (message.sdkLanguage !== "") {
      writer.uint32(98).string(message.sdkLanguage);
    }
    if (message.startedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.startedAt), writer.uint32(106).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkerConnectRequestData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkerConnectRequestData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.connectionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.instanceId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.authData = AuthData.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.capabilities = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.apps.push(AppConfiguration.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.workerManualReadinessAck = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.systemAttributes = SystemAttributes.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.environment = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.framework = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.platform = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.sdkVersion = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.sdkLanguage = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.startedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkerConnectRequestData {
    return {
      connectionId: isSet(object.connectionId) ? globalThis.String(object.connectionId) : "",
      instanceId: isSet(object.instanceId) ? globalThis.String(object.instanceId) : "",
      authData: isSet(object.authData) ? AuthData.fromJSON(object.authData) : undefined,
      capabilities: isSet(object.capabilities) ? bytesFromBase64(object.capabilities) : new Uint8Array(0),
      apps: globalThis.Array.isArray(object?.apps) ? object.apps.map((e: any) => AppConfiguration.fromJSON(e)) : [],
      workerManualReadinessAck: isSet(object.workerManualReadinessAck)
        ? globalThis.Boolean(object.workerManualReadinessAck)
        : false,
      systemAttributes: isSet(object.systemAttributes) ? SystemAttributes.fromJSON(object.systemAttributes) : undefined,
      environment: isSet(object.environment) ? globalThis.String(object.environment) : undefined,
      framework: isSet(object.framework) ? globalThis.String(object.framework) : "",
      platform: isSet(object.platform) ? globalThis.String(object.platform) : undefined,
      sdkVersion: isSet(object.sdkVersion) ? globalThis.String(object.sdkVersion) : "",
      sdkLanguage: isSet(object.sdkLanguage) ? globalThis.String(object.sdkLanguage) : "",
      startedAt: isSet(object.startedAt) ? fromJsonTimestamp(object.startedAt) : undefined,
    };
  },

  toJSON(message: WorkerConnectRequestData): unknown {
    const obj: any = {};
    if (message.connectionId !== "") {
      obj.connectionId = message.connectionId;
    }
    if (message.instanceId !== "") {
      obj.instanceId = message.instanceId;
    }
    if (message.authData !== undefined) {
      obj.authData = AuthData.toJSON(message.authData);
    }
    if (message.capabilities.length !== 0) {
      obj.capabilities = base64FromBytes(message.capabilities);
    }
    if (message.apps?.length) {
      obj.apps = message.apps.map((e) => AppConfiguration.toJSON(e));
    }
    if (message.workerManualReadinessAck !== false) {
      obj.workerManualReadinessAck = message.workerManualReadinessAck;
    }
    if (message.systemAttributes !== undefined) {
      obj.systemAttributes = SystemAttributes.toJSON(message.systemAttributes);
    }
    if (message.environment !== undefined) {
      obj.environment = message.environment;
    }
    if (message.framework !== "") {
      obj.framework = message.framework;
    }
    if (message.platform !== undefined) {
      obj.platform = message.platform;
    }
    if (message.sdkVersion !== "") {
      obj.sdkVersion = message.sdkVersion;
    }
    if (message.sdkLanguage !== "") {
      obj.sdkLanguage = message.sdkLanguage;
    }
    if (message.startedAt !== undefined) {
      obj.startedAt = message.startedAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorkerConnectRequestData>, I>>(base?: I): WorkerConnectRequestData {
    return WorkerConnectRequestData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorkerConnectRequestData>, I>>(object: I): WorkerConnectRequestData {
    const message = createBaseWorkerConnectRequestData();
    message.connectionId = object.connectionId ?? "";
    message.instanceId = object.instanceId ?? "";
    message.authData = (object.authData !== undefined && object.authData !== null)
      ? AuthData.fromPartial(object.authData)
      : undefined;
    message.capabilities = object.capabilities ?? new Uint8Array(0);
    message.apps = object.apps?.map((e) => AppConfiguration.fromPartial(e)) || [];
    message.workerManualReadinessAck = object.workerManualReadinessAck ?? false;
    message.systemAttributes = (object.systemAttributes !== undefined && object.systemAttributes !== null)
      ? SystemAttributes.fromPartial(object.systemAttributes)
      : undefined;
    message.environment = object.environment ?? undefined;
    message.framework = object.framework ?? "";
    message.platform = object.platform ?? undefined;
    message.sdkVersion = object.sdkVersion ?? "";
    message.sdkLanguage = object.sdkLanguage ?? "";
    message.startedAt = object.startedAt ?? undefined;
    return message;
  },
};

function createBaseGatewayExecutorRequestData(): GatewayExecutorRequestData {
  return {
    requestId: "",
    accountId: "",
    envId: "",
    appId: "",
    appName: "",
    functionId: "",
    functionSlug: "",
    stepId: undefined,
    requestPayload: new Uint8Array(0),
    systemTraceCtx: new Uint8Array(0),
    userTraceCtx: new Uint8Array(0),
  };
}

export const GatewayExecutorRequestData: MessageFns<GatewayExecutorRequestData> = {
  encode(message: GatewayExecutorRequestData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.accountId !== "") {
      writer.uint32(18).string(message.accountId);
    }
    if (message.envId !== "") {
      writer.uint32(26).string(message.envId);
    }
    if (message.appId !== "") {
      writer.uint32(34).string(message.appId);
    }
    if (message.appName !== "") {
      writer.uint32(42).string(message.appName);
    }
    if (message.functionId !== "") {
      writer.uint32(50).string(message.functionId);
    }
    if (message.functionSlug !== "") {
      writer.uint32(58).string(message.functionSlug);
    }
    if (message.stepId !== undefined) {
      writer.uint32(66).string(message.stepId);
    }
    if (message.requestPayload.length !== 0) {
      writer.uint32(74).bytes(message.requestPayload);
    }
    if (message.systemTraceCtx.length !== 0) {
      writer.uint32(82).bytes(message.systemTraceCtx);
    }
    if (message.userTraceCtx.length !== 0) {
      writer.uint32(90).bytes(message.userTraceCtx);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GatewayExecutorRequestData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGatewayExecutorRequestData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.accountId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.envId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.appId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.appName = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.functionId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.functionSlug = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.stepId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.requestPayload = reader.bytes();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.systemTraceCtx = reader.bytes();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.userTraceCtx = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GatewayExecutorRequestData {
    return {
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      accountId: isSet(object.accountId) ? globalThis.String(object.accountId) : "",
      envId: isSet(object.envId) ? globalThis.String(object.envId) : "",
      appId: isSet(object.appId) ? globalThis.String(object.appId) : "",
      appName: isSet(object.appName) ? globalThis.String(object.appName) : "",
      functionId: isSet(object.functionId) ? globalThis.String(object.functionId) : "",
      functionSlug: isSet(object.functionSlug) ? globalThis.String(object.functionSlug) : "",
      stepId: isSet(object.stepId) ? globalThis.String(object.stepId) : undefined,
      requestPayload: isSet(object.requestPayload) ? bytesFromBase64(object.requestPayload) : new Uint8Array(0),
      systemTraceCtx: isSet(object.systemTraceCtx) ? bytesFromBase64(object.systemTraceCtx) : new Uint8Array(0),
      userTraceCtx: isSet(object.userTraceCtx) ? bytesFromBase64(object.userTraceCtx) : new Uint8Array(0),
    };
  },

  toJSON(message: GatewayExecutorRequestData): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.accountId !== "") {
      obj.accountId = message.accountId;
    }
    if (message.envId !== "") {
      obj.envId = message.envId;
    }
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    if (message.appName !== "") {
      obj.appName = message.appName;
    }
    if (message.functionId !== "") {
      obj.functionId = message.functionId;
    }
    if (message.functionSlug !== "") {
      obj.functionSlug = message.functionSlug;
    }
    if (message.stepId !== undefined) {
      obj.stepId = message.stepId;
    }
    if (message.requestPayload.length !== 0) {
      obj.requestPayload = base64FromBytes(message.requestPayload);
    }
    if (message.systemTraceCtx.length !== 0) {
      obj.systemTraceCtx = base64FromBytes(message.systemTraceCtx);
    }
    if (message.userTraceCtx.length !== 0) {
      obj.userTraceCtx = base64FromBytes(message.userTraceCtx);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GatewayExecutorRequestData>, I>>(base?: I): GatewayExecutorRequestData {
    return GatewayExecutorRequestData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GatewayExecutorRequestData>, I>>(object: I): GatewayExecutorRequestData {
    const message = createBaseGatewayExecutorRequestData();
    message.requestId = object.requestId ?? "";
    message.accountId = object.accountId ?? "";
    message.envId = object.envId ?? "";
    message.appId = object.appId ?? "";
    message.appName = object.appName ?? "";
    message.functionId = object.functionId ?? "";
    message.functionSlug = object.functionSlug ?? "";
    message.stepId = object.stepId ?? undefined;
    message.requestPayload = object.requestPayload ?? new Uint8Array(0);
    message.systemTraceCtx = object.systemTraceCtx ?? new Uint8Array(0);
    message.userTraceCtx = object.userTraceCtx ?? new Uint8Array(0);
    return message;
  },
};

function createBaseWorkerRequestAckData(): WorkerRequestAckData {
  return {
    requestId: "",
    accountId: "",
    envId: "",
    appId: "",
    functionSlug: "",
    stepId: undefined,
    systemTraceCtx: new Uint8Array(0),
    userTraceCtx: new Uint8Array(0),
  };
}

export const WorkerRequestAckData: MessageFns<WorkerRequestAckData> = {
  encode(message: WorkerRequestAckData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.accountId !== "") {
      writer.uint32(18).string(message.accountId);
    }
    if (message.envId !== "") {
      writer.uint32(26).string(message.envId);
    }
    if (message.appId !== "") {
      writer.uint32(34).string(message.appId);
    }
    if (message.functionSlug !== "") {
      writer.uint32(42).string(message.functionSlug);
    }
    if (message.stepId !== undefined) {
      writer.uint32(50).string(message.stepId);
    }
    if (message.systemTraceCtx.length !== 0) {
      writer.uint32(58).bytes(message.systemTraceCtx);
    }
    if (message.userTraceCtx.length !== 0) {
      writer.uint32(66).bytes(message.userTraceCtx);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkerRequestAckData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkerRequestAckData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.accountId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.envId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.appId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.functionSlug = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.stepId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.systemTraceCtx = reader.bytes();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.userTraceCtx = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkerRequestAckData {
    return {
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      accountId: isSet(object.accountId) ? globalThis.String(object.accountId) : "",
      envId: isSet(object.envId) ? globalThis.String(object.envId) : "",
      appId: isSet(object.appId) ? globalThis.String(object.appId) : "",
      functionSlug: isSet(object.functionSlug) ? globalThis.String(object.functionSlug) : "",
      stepId: isSet(object.stepId) ? globalThis.String(object.stepId) : undefined,
      systemTraceCtx: isSet(object.systemTraceCtx) ? bytesFromBase64(object.systemTraceCtx) : new Uint8Array(0),
      userTraceCtx: isSet(object.userTraceCtx) ? bytesFromBase64(object.userTraceCtx) : new Uint8Array(0),
    };
  },

  toJSON(message: WorkerRequestAckData): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.accountId !== "") {
      obj.accountId = message.accountId;
    }
    if (message.envId !== "") {
      obj.envId = message.envId;
    }
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    if (message.functionSlug !== "") {
      obj.functionSlug = message.functionSlug;
    }
    if (message.stepId !== undefined) {
      obj.stepId = message.stepId;
    }
    if (message.systemTraceCtx.length !== 0) {
      obj.systemTraceCtx = base64FromBytes(message.systemTraceCtx);
    }
    if (message.userTraceCtx.length !== 0) {
      obj.userTraceCtx = base64FromBytes(message.userTraceCtx);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorkerRequestAckData>, I>>(base?: I): WorkerRequestAckData {
    return WorkerRequestAckData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorkerRequestAckData>, I>>(object: I): WorkerRequestAckData {
    const message = createBaseWorkerRequestAckData();
    message.requestId = object.requestId ?? "";
    message.accountId = object.accountId ?? "";
    message.envId = object.envId ?? "";
    message.appId = object.appId ?? "";
    message.functionSlug = object.functionSlug ?? "";
    message.stepId = object.stepId ?? undefined;
    message.systemTraceCtx = object.systemTraceCtx ?? new Uint8Array(0);
    message.userTraceCtx = object.userTraceCtx ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSDKResponse(): SDKResponse {
  return {
    requestId: "",
    accountId: "",
    envId: "",
    appId: "",
    status: 0,
    body: new Uint8Array(0),
    noRetry: false,
    retryAfter: undefined,
    sdkVersion: "",
    requestVersion: 0,
    systemTraceCtx: new Uint8Array(0),
    userTraceCtx: new Uint8Array(0),
  };
}

export const SDKResponse: MessageFns<SDKResponse> = {
  encode(message: SDKResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.accountId !== "") {
      writer.uint32(18).string(message.accountId);
    }
    if (message.envId !== "") {
      writer.uint32(26).string(message.envId);
    }
    if (message.appId !== "") {
      writer.uint32(34).string(message.appId);
    }
    if (message.status !== 0) {
      writer.uint32(40).int32(message.status);
    }
    if (message.body.length !== 0) {
      writer.uint32(50).bytes(message.body);
    }
    if (message.noRetry !== false) {
      writer.uint32(56).bool(message.noRetry);
    }
    if (message.retryAfter !== undefined) {
      writer.uint32(66).string(message.retryAfter);
    }
    if (message.sdkVersion !== "") {
      writer.uint32(74).string(message.sdkVersion);
    }
    if (message.requestVersion !== 0) {
      writer.uint32(80).uint32(message.requestVersion);
    }
    if (message.systemTraceCtx.length !== 0) {
      writer.uint32(90).bytes(message.systemTraceCtx);
    }
    if (message.userTraceCtx.length !== 0) {
      writer.uint32(98).bytes(message.userTraceCtx);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SDKResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSDKResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.accountId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.envId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.appId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.body = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.noRetry = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.retryAfter = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.sdkVersion = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.requestVersion = reader.uint32();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.systemTraceCtx = reader.bytes();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.userTraceCtx = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SDKResponse {
    return {
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      accountId: isSet(object.accountId) ? globalThis.String(object.accountId) : "",
      envId: isSet(object.envId) ? globalThis.String(object.envId) : "",
      appId: isSet(object.appId) ? globalThis.String(object.appId) : "",
      status: isSet(object.status) ? sDKResponseStatusFromJSON(object.status) : 0,
      body: isSet(object.body) ? bytesFromBase64(object.body) : new Uint8Array(0),
      noRetry: isSet(object.noRetry) ? globalThis.Boolean(object.noRetry) : false,
      retryAfter: isSet(object.retryAfter) ? globalThis.String(object.retryAfter) : undefined,
      sdkVersion: isSet(object.sdkVersion) ? globalThis.String(object.sdkVersion) : "",
      requestVersion: isSet(object.requestVersion) ? globalThis.Number(object.requestVersion) : 0,
      systemTraceCtx: isSet(object.systemTraceCtx) ? bytesFromBase64(object.systemTraceCtx) : new Uint8Array(0),
      userTraceCtx: isSet(object.userTraceCtx) ? bytesFromBase64(object.userTraceCtx) : new Uint8Array(0),
    };
  },

  toJSON(message: SDKResponse): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.accountId !== "") {
      obj.accountId = message.accountId;
    }
    if (message.envId !== "") {
      obj.envId = message.envId;
    }
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    if (message.status !== 0) {
      obj.status = sDKResponseStatusToJSON(message.status);
    }
    if (message.body.length !== 0) {
      obj.body = base64FromBytes(message.body);
    }
    if (message.noRetry !== false) {
      obj.noRetry = message.noRetry;
    }
    if (message.retryAfter !== undefined) {
      obj.retryAfter = message.retryAfter;
    }
    if (message.sdkVersion !== "") {
      obj.sdkVersion = message.sdkVersion;
    }
    if (message.requestVersion !== 0) {
      obj.requestVersion = Math.round(message.requestVersion);
    }
    if (message.systemTraceCtx.length !== 0) {
      obj.systemTraceCtx = base64FromBytes(message.systemTraceCtx);
    }
    if (message.userTraceCtx.length !== 0) {
      obj.userTraceCtx = base64FromBytes(message.userTraceCtx);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SDKResponse>, I>>(base?: I): SDKResponse {
    return SDKResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SDKResponse>, I>>(object: I): SDKResponse {
    const message = createBaseSDKResponse();
    message.requestId = object.requestId ?? "";
    message.accountId = object.accountId ?? "";
    message.envId = object.envId ?? "";
    message.appId = object.appId ?? "";
    message.status = object.status ?? 0;
    message.body = object.body ?? new Uint8Array(0);
    message.noRetry = object.noRetry ?? false;
    message.retryAfter = object.retryAfter ?? undefined;
    message.sdkVersion = object.sdkVersion ?? "";
    message.requestVersion = object.requestVersion ?? 0;
    message.systemTraceCtx = object.systemTraceCtx ?? new Uint8Array(0);
    message.userTraceCtx = object.userTraceCtx ?? new Uint8Array(0);
    return message;
  },
};

function createBaseWorkerReplyAckData(): WorkerReplyAckData {
  return { requestId: "" };
}

export const WorkerReplyAckData: MessageFns<WorkerReplyAckData> = {
  encode(message: WorkerReplyAckData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkerReplyAckData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkerReplyAckData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkerReplyAckData {
    return { requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "" };
  },

  toJSON(message: WorkerReplyAckData): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorkerReplyAckData>, I>>(base?: I): WorkerReplyAckData {
    return WorkerReplyAckData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorkerReplyAckData>, I>>(object: I): WorkerReplyAckData {
    const message = createBaseWorkerReplyAckData();
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseConnMetadata(): ConnMetadata {
  return {
    id: "",
    gatewayId: "",
    instanceId: "",
    workerGroups: {},
    status: 0,
    lastHeartbeatAt: undefined,
    sdkLanguage: "",
    sdkVersion: "",
    attributes: undefined,
  };
}

export const ConnMetadata: MessageFns<ConnMetadata> = {
  encode(message: ConnMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.gatewayId !== "") {
      writer.uint32(18).string(message.gatewayId);
    }
    if (message.instanceId !== "") {
      writer.uint32(26).string(message.instanceId);
    }
    Object.entries(message.workerGroups).forEach(([key, value]) => {
      ConnMetadata_WorkerGroupsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.status !== 0) {
      writer.uint32(40).int32(message.status);
    }
    if (message.lastHeartbeatAt !== undefined) {
      Timestamp.encode(toTimestamp(message.lastHeartbeatAt), writer.uint32(50).fork()).join();
    }
    if (message.sdkLanguage !== "") {
      writer.uint32(58).string(message.sdkLanguage);
    }
    if (message.sdkVersion !== "") {
      writer.uint32(66).string(message.sdkVersion);
    }
    if (message.attributes !== undefined) {
      SystemAttributes.encode(message.attributes, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConnMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.gatewayId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.instanceId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = ConnMetadata_WorkerGroupsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.workerGroups[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.lastHeartbeatAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.sdkLanguage = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.sdkVersion = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.attributes = SystemAttributes.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConnMetadata {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      gatewayId: isSet(object.gatewayId) ? globalThis.String(object.gatewayId) : "",
      instanceId: isSet(object.instanceId) ? globalThis.String(object.instanceId) : "",
      workerGroups: isObject(object.workerGroups)
        ? Object.entries(object.workerGroups).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      status: isSet(object.status) ? connectionStatusFromJSON(object.status) : 0,
      lastHeartbeatAt: isSet(object.lastHeartbeatAt) ? fromJsonTimestamp(object.lastHeartbeatAt) : undefined,
      sdkLanguage: isSet(object.sdkLanguage) ? globalThis.String(object.sdkLanguage) : "",
      sdkVersion: isSet(object.sdkVersion) ? globalThis.String(object.sdkVersion) : "",
      attributes: isSet(object.attributes) ? SystemAttributes.fromJSON(object.attributes) : undefined,
    };
  },

  toJSON(message: ConnMetadata): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.gatewayId !== "") {
      obj.gatewayId = message.gatewayId;
    }
    if (message.instanceId !== "") {
      obj.instanceId = message.instanceId;
    }
    if (message.workerGroups) {
      const entries = Object.entries(message.workerGroups);
      if (entries.length > 0) {
        obj.workerGroups = {};
        entries.forEach(([k, v]) => {
          obj.workerGroups[k] = v;
        });
      }
    }
    if (message.status !== 0) {
      obj.status = connectionStatusToJSON(message.status);
    }
    if (message.lastHeartbeatAt !== undefined) {
      obj.lastHeartbeatAt = message.lastHeartbeatAt.toISOString();
    }
    if (message.sdkLanguage !== "") {
      obj.sdkLanguage = message.sdkLanguage;
    }
    if (message.sdkVersion !== "") {
      obj.sdkVersion = message.sdkVersion;
    }
    if (message.attributes !== undefined) {
      obj.attributes = SystemAttributes.toJSON(message.attributes);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConnMetadata>, I>>(base?: I): ConnMetadata {
    return ConnMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConnMetadata>, I>>(object: I): ConnMetadata {
    const message = createBaseConnMetadata();
    message.id = object.id ?? "";
    message.gatewayId = object.gatewayId ?? "";
    message.instanceId = object.instanceId ?? "";
    message.workerGroups = Object.entries(object.workerGroups ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.status = object.status ?? 0;
    message.lastHeartbeatAt = object.lastHeartbeatAt ?? undefined;
    message.sdkLanguage = object.sdkLanguage ?? "";
    message.sdkVersion = object.sdkVersion ?? "";
    message.attributes = (object.attributes !== undefined && object.attributes !== null)
      ? SystemAttributes.fromPartial(object.attributes)
      : undefined;
    return message;
  },
};

function createBaseConnMetadata_WorkerGroupsEntry(): ConnMetadata_WorkerGroupsEntry {
  return { key: "", value: "" };
}

export const ConnMetadata_WorkerGroupsEntry: MessageFns<ConnMetadata_WorkerGroupsEntry> = {
  encode(message: ConnMetadata_WorkerGroupsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConnMetadata_WorkerGroupsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnMetadata_WorkerGroupsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConnMetadata_WorkerGroupsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ConnMetadata_WorkerGroupsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConnMetadata_WorkerGroupsEntry>, I>>(base?: I): ConnMetadata_WorkerGroupsEntry {
    return ConnMetadata_WorkerGroupsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConnMetadata_WorkerGroupsEntry>, I>>(
    object: I,
  ): ConnMetadata_WorkerGroupsEntry {
    const message = createBaseConnMetadata_WorkerGroupsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSystemAttributes(): SystemAttributes {
  return { cpuCores: 0, memBytes: 0, os: "" };
}

export const SystemAttributes: MessageFns<SystemAttributes> = {
  encode(message: SystemAttributes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cpuCores !== 0) {
      writer.uint32(8).int32(message.cpuCores);
    }
    if (message.memBytes !== 0) {
      writer.uint32(16).int64(message.memBytes);
    }
    if (message.os !== "") {
      writer.uint32(26).string(message.os);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SystemAttributes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSystemAttributes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.cpuCores = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.memBytes = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.os = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SystemAttributes {
    return {
      cpuCores: isSet(object.cpuCores) ? globalThis.Number(object.cpuCores) : 0,
      memBytes: isSet(object.memBytes) ? globalThis.Number(object.memBytes) : 0,
      os: isSet(object.os) ? globalThis.String(object.os) : "",
    };
  },

  toJSON(message: SystemAttributes): unknown {
    const obj: any = {};
    if (message.cpuCores !== 0) {
      obj.cpuCores = Math.round(message.cpuCores);
    }
    if (message.memBytes !== 0) {
      obj.memBytes = Math.round(message.memBytes);
    }
    if (message.os !== "") {
      obj.os = message.os;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SystemAttributes>, I>>(base?: I): SystemAttributes {
    return SystemAttributes.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SystemAttributes>, I>>(object: I): SystemAttributes {
    const message = createBaseSystemAttributes();
    message.cpuCores = object.cpuCores ?? 0;
    message.memBytes = object.memBytes ?? 0;
    message.os = object.os ?? "";
    return message;
  },
};

function createBaseConnGroup(): ConnGroup {
  return { envId: "", appId: "", appName: "", hash: "", conns: [], syncId: undefined, appVersion: undefined };
}

export const ConnGroup: MessageFns<ConnGroup> = {
  encode(message: ConnGroup, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.envId !== "") {
      writer.uint32(10).string(message.envId);
    }
    if (message.appId !== "") {
      writer.uint32(18).string(message.appId);
    }
    if (message.appName !== "") {
      writer.uint32(26).string(message.appName);
    }
    if (message.hash !== "") {
      writer.uint32(34).string(message.hash);
    }
    for (const v of message.conns) {
      ConnMetadata.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.syncId !== undefined) {
      writer.uint32(50).string(message.syncId);
    }
    if (message.appVersion !== undefined) {
      writer.uint32(58).string(message.appVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConnGroup {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.envId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.appId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.appName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.hash = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.conns.push(ConnMetadata.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.syncId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.appVersion = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConnGroup {
    return {
      envId: isSet(object.envId) ? globalThis.String(object.envId) : "",
      appId: isSet(object.appId) ? globalThis.String(object.appId) : "",
      appName: isSet(object.appName) ? globalThis.String(object.appName) : "",
      hash: isSet(object.hash) ? globalThis.String(object.hash) : "",
      conns: globalThis.Array.isArray(object?.conns) ? object.conns.map((e: any) => ConnMetadata.fromJSON(e)) : [],
      syncId: isSet(object.syncId) ? globalThis.String(object.syncId) : undefined,
      appVersion: isSet(object.appVersion) ? globalThis.String(object.appVersion) : undefined,
    };
  },

  toJSON(message: ConnGroup): unknown {
    const obj: any = {};
    if (message.envId !== "") {
      obj.envId = message.envId;
    }
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    if (message.appName !== "") {
      obj.appName = message.appName;
    }
    if (message.hash !== "") {
      obj.hash = message.hash;
    }
    if (message.conns?.length) {
      obj.conns = message.conns.map((e) => ConnMetadata.toJSON(e));
    }
    if (message.syncId !== undefined) {
      obj.syncId = message.syncId;
    }
    if (message.appVersion !== undefined) {
      obj.appVersion = message.appVersion;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConnGroup>, I>>(base?: I): ConnGroup {
    return ConnGroup.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConnGroup>, I>>(object: I): ConnGroup {
    const message = createBaseConnGroup();
    message.envId = object.envId ?? "";
    message.appId = object.appId ?? "";
    message.appName = object.appName ?? "";
    message.hash = object.hash ?? "";
    message.conns = object.conns?.map((e) => ConnMetadata.fromPartial(e)) || [];
    message.syncId = object.syncId ?? undefined;
    message.appVersion = object.appVersion ?? undefined;
    return message;
  },
};

function createBaseStartResponse(): StartResponse {
  return { connectionId: "", gatewayEndpoint: "", gatewayGroup: "", sessionToken: "", syncToken: "" };
}

export const StartResponse: MessageFns<StartResponse> = {
  encode(message: StartResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.connectionId !== "") {
      writer.uint32(10).string(message.connectionId);
    }
    if (message.gatewayEndpoint !== "") {
      writer.uint32(18).string(message.gatewayEndpoint);
    }
    if (message.gatewayGroup !== "") {
      writer.uint32(26).string(message.gatewayGroup);
    }
    if (message.sessionToken !== "") {
      writer.uint32(34).string(message.sessionToken);
    }
    if (message.syncToken !== "") {
      writer.uint32(42).string(message.syncToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.connectionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.gatewayEndpoint = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.gatewayGroup = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sessionToken = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.syncToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartResponse {
    return {
      connectionId: isSet(object.connectionId) ? globalThis.String(object.connectionId) : "",
      gatewayEndpoint: isSet(object.gatewayEndpoint) ? globalThis.String(object.gatewayEndpoint) : "",
      gatewayGroup: isSet(object.gatewayGroup) ? globalThis.String(object.gatewayGroup) : "",
      sessionToken: isSet(object.sessionToken) ? globalThis.String(object.sessionToken) : "",
      syncToken: isSet(object.syncToken) ? globalThis.String(object.syncToken) : "",
    };
  },

  toJSON(message: StartResponse): unknown {
    const obj: any = {};
    if (message.connectionId !== "") {
      obj.connectionId = message.connectionId;
    }
    if (message.gatewayEndpoint !== "") {
      obj.gatewayEndpoint = message.gatewayEndpoint;
    }
    if (message.gatewayGroup !== "") {
      obj.gatewayGroup = message.gatewayGroup;
    }
    if (message.sessionToken !== "") {
      obj.sessionToken = message.sessionToken;
    }
    if (message.syncToken !== "") {
      obj.syncToken = message.syncToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StartResponse>, I>>(base?: I): StartResponse {
    return StartResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StartResponse>, I>>(object: I): StartResponse {
    const message = createBaseStartResponse();
    message.connectionId = object.connectionId ?? "";
    message.gatewayEndpoint = object.gatewayEndpoint ?? "";
    message.gatewayGroup = object.gatewayGroup ?? "";
    message.sessionToken = object.sessionToken ?? "";
    message.syncToken = object.syncToken ?? "";
    return message;
  },
};

function createBaseStartRequest(): StartRequest {
  return { excludeGateways: [] };
}

export const StartRequest: MessageFns<StartRequest> = {
  encode(message: StartRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.excludeGateways) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.excludeGateways.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartRequest {
    return {
      excludeGateways: globalThis.Array.isArray(object?.excludeGateways)
        ? object.excludeGateways.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: StartRequest): unknown {
    const obj: any = {};
    if (message.excludeGateways?.length) {
      obj.excludeGateways = message.excludeGateways;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StartRequest>, I>>(base?: I): StartRequest {
    return StartRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StartRequest>, I>>(object: I): StartRequest {
    const message = createBaseStartRequest();
    message.excludeGateways = object.excludeGateways?.map((e) => e) || [];
    return message;
  },
};

function createBaseFlushResponse(): FlushResponse {
  return { requestId: "" };
}

export const FlushResponse: MessageFns<FlushResponse> = {
  encode(message: FlushResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FlushResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFlushResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FlushResponse {
    return { requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "" };
  },

  toJSON(message: FlushResponse): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FlushResponse>, I>>(base?: I): FlushResponse {
    return FlushResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FlushResponse>, I>>(object: I): FlushResponse {
    const message = createBaseFlushResponse();
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBasePubSubAckMessage(): PubSubAckMessage {
  return { ts: undefined, nack: undefined, nackReason: undefined };
}

export const PubSubAckMessage: MessageFns<PubSubAckMessage> = {
  encode(message: PubSubAckMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ts !== undefined) {
      Timestamp.encode(toTimestamp(message.ts), writer.uint32(10).fork()).join();
    }
    if (message.nack !== undefined) {
      writer.uint32(16).bool(message.nack);
    }
    if (message.nackReason !== undefined) {
      SystemError.encode(message.nackReason, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PubSubAckMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePubSubAckMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ts = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.nack = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nackReason = SystemError.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PubSubAckMessage {
    return {
      ts: isSet(object.ts) ? fromJsonTimestamp(object.ts) : undefined,
      nack: isSet(object.nack) ? globalThis.Boolean(object.nack) : undefined,
      nackReason: isSet(object.nackReason) ? SystemError.fromJSON(object.nackReason) : undefined,
    };
  },

  toJSON(message: PubSubAckMessage): unknown {
    const obj: any = {};
    if (message.ts !== undefined) {
      obj.ts = message.ts.toISOString();
    }
    if (message.nack !== undefined) {
      obj.nack = message.nack;
    }
    if (message.nackReason !== undefined) {
      obj.nackReason = SystemError.toJSON(message.nackReason);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PubSubAckMessage>, I>>(base?: I): PubSubAckMessage {
    return PubSubAckMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PubSubAckMessage>, I>>(object: I): PubSubAckMessage {
    const message = createBasePubSubAckMessage();
    message.ts = object.ts ?? undefined;
    message.nack = object.nack ?? undefined;
    message.nackReason = (object.nackReason !== undefined && object.nackReason !== null)
      ? SystemError.fromPartial(object.nackReason)
      : undefined;
    return message;
  },
};

function createBaseSystemError(): SystemError {
  return { code: "", data: undefined, message: "" };
}

export const SystemError: MessageFns<SystemError> = {
  encode(message: SystemError, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    if (message.data !== undefined) {
      writer.uint32(18).bytes(message.data);
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SystemError {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSystemError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SystemError {
    return {
      code: isSet(object.code) ? globalThis.String(object.code) : "",
      data: isSet(object.data) ? bytesFromBase64(object.data) : undefined,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: SystemError): unknown {
    const obj: any = {};
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.data !== undefined) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SystemError>, I>>(base?: I): SystemError {
    return SystemError.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SystemError>, I>>(object: I): SystemError {
    const message = createBaseSystemError();
    message.code = object.code ?? "";
    message.data = object.data ?? undefined;
    message.message = object.message ?? "";
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
