// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               v5.29.3
// source: src/components/connect/protobuf/connect.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Timestamp } from "../../../../google/protobuf/timestamp";

export const protobufPackage = "connect.v1";

export enum GatewayMessageType {
  GATEWAY_HELLO = 0,
  WORKER_CONNECT = 1,
  GATEWAY_CONNECTION_READY = 2,
  GATEWAY_EXECUTOR_REQUEST = 3,
  WORKER_READY = 4,
  WORKER_REQUEST_ACK = 5,
  WORKER_REPLY = 6,
  WORKER_PAUSE = 7,
  WORKER_HEARTBEAT = 8,
  GATEWAY_CLOSING = 9,
  UNRECOGNIZED = -1,
}

export function gatewayMessageTypeFromJSON(object: any): GatewayMessageType {
  switch (object) {
    case 0:
    case "GATEWAY_HELLO":
      return GatewayMessageType.GATEWAY_HELLO;
    case 1:
    case "WORKER_CONNECT":
      return GatewayMessageType.WORKER_CONNECT;
    case 2:
    case "GATEWAY_CONNECTION_READY":
      return GatewayMessageType.GATEWAY_CONNECTION_READY;
    case 3:
    case "GATEWAY_EXECUTOR_REQUEST":
      return GatewayMessageType.GATEWAY_EXECUTOR_REQUEST;
    case 4:
    case "WORKER_READY":
      return GatewayMessageType.WORKER_READY;
    case 5:
    case "WORKER_REQUEST_ACK":
      return GatewayMessageType.WORKER_REQUEST_ACK;
    case 6:
    case "WORKER_REPLY":
      return GatewayMessageType.WORKER_REPLY;
    case 7:
    case "WORKER_PAUSE":
      return GatewayMessageType.WORKER_PAUSE;
    case 8:
    case "WORKER_HEARTBEAT":
      return GatewayMessageType.WORKER_HEARTBEAT;
    case 9:
    case "GATEWAY_CLOSING":
      return GatewayMessageType.GATEWAY_CLOSING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GatewayMessageType.UNRECOGNIZED;
  }
}

export function gatewayMessageTypeToJSON(object: GatewayMessageType): string {
  switch (object) {
    case GatewayMessageType.GATEWAY_HELLO:
      return "GATEWAY_HELLO";
    case GatewayMessageType.WORKER_CONNECT:
      return "WORKER_CONNECT";
    case GatewayMessageType.GATEWAY_CONNECTION_READY:
      return "GATEWAY_CONNECTION_READY";
    case GatewayMessageType.GATEWAY_EXECUTOR_REQUEST:
      return "GATEWAY_EXECUTOR_REQUEST";
    case GatewayMessageType.WORKER_READY:
      return "WORKER_READY";
    case GatewayMessageType.WORKER_REQUEST_ACK:
      return "WORKER_REQUEST_ACK";
    case GatewayMessageType.WORKER_REPLY:
      return "WORKER_REPLY";
    case GatewayMessageType.WORKER_PAUSE:
      return "WORKER_PAUSE";
    case GatewayMessageType.WORKER_HEARTBEAT:
      return "WORKER_HEARTBEAT";
    case GatewayMessageType.GATEWAY_CLOSING:
      return "GATEWAY_CLOSING";
    case GatewayMessageType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum SDKResponseStatus {
  NOT_COMPLETED = 0,
  DONE = 1,
  ERROR = 2,
  UNRECOGNIZED = -1,
}

export function sDKResponseStatusFromJSON(object: any): SDKResponseStatus {
  switch (object) {
    case 0:
    case "NOT_COMPLETED":
      return SDKResponseStatus.NOT_COMPLETED;
    case 1:
    case "DONE":
      return SDKResponseStatus.DONE;
    case 2:
    case "ERROR":
      return SDKResponseStatus.ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SDKResponseStatus.UNRECOGNIZED;
  }
}

export function sDKResponseStatusToJSON(object: SDKResponseStatus): string {
  switch (object) {
    case SDKResponseStatus.NOT_COMPLETED:
      return "NOT_COMPLETED";
    case SDKResponseStatus.DONE:
      return "DONE";
    case SDKResponseStatus.ERROR:
      return "ERROR";
    case SDKResponseStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ConnectionStatus {
  CONNECTED = 0,
  READY = 1,
  DRAINING = 2,
  DISCONNECTING = 3,
  DISCONNECTED = 4,
  UNRECOGNIZED = -1,
}

export function connectionStatusFromJSON(object: any): ConnectionStatus {
  switch (object) {
    case 0:
    case "CONNECTED":
      return ConnectionStatus.CONNECTED;
    case 1:
    case "READY":
      return ConnectionStatus.READY;
    case 2:
    case "DRAINING":
      return ConnectionStatus.DRAINING;
    case 3:
    case "DISCONNECTING":
      return ConnectionStatus.DISCONNECTING;
    case 4:
    case "DISCONNECTED":
      return ConnectionStatus.DISCONNECTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ConnectionStatus.UNRECOGNIZED;
  }
}

export function connectionStatusToJSON(object: ConnectionStatus): string {
  switch (object) {
    case ConnectionStatus.CONNECTED:
      return "CONNECTED";
    case ConnectionStatus.READY:
      return "READY";
    case ConnectionStatus.DRAINING:
      return "DRAINING";
    case ConnectionStatus.DISCONNECTING:
      return "DISCONNECTING";
    case ConnectionStatus.DISCONNECTED:
      return "DISCONNECTED";
    case ConnectionStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum WorkerDisconnectReason {
  WORKER_SHUTDOWN = 0,
  UNRECOGNIZED = -1,
}

export function workerDisconnectReasonFromJSON(object: any): WorkerDisconnectReason {
  switch (object) {
    case 0:
    case "WORKER_SHUTDOWN":
      return WorkerDisconnectReason.WORKER_SHUTDOWN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WorkerDisconnectReason.UNRECOGNIZED;
  }
}

export function workerDisconnectReasonToJSON(object: WorkerDisconnectReason): string {
  switch (object) {
    case WorkerDisconnectReason.WORKER_SHUTDOWN:
      return "WORKER_SHUTDOWN";
    case WorkerDisconnectReason.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface ConnectMessage {
  kind: GatewayMessageType;
  payload: Uint8Array;
}

export interface SessionIdentifier {
  instanceId: string;
  connectionId: string;
  buildId?: string | undefined;
}

export interface SessionDetails {
  sessionId: SessionIdentifier | undefined;
  functionHash: Uint8Array;
}

export interface ConfigDetails {
  capabilities: Uint8Array;
  functions: Uint8Array;
}

export interface AuthData {
  sessionToken: string;
  syncToken: string;
}

export interface WorkerConnectRequestData {
  sessionId: SessionIdentifier | undefined;
  authData: AuthData | undefined;
  appName: string;
  config: ConfigDetails | undefined;
  workerManualReadinessAck: boolean;
  systemAttributes: SystemAttributes | undefined;
  environment?: string | undefined;
  framework: string;
  platform?: string | undefined;
  sdkVersion: string;
  sdkLanguage: string;
  startedAt: Date | undefined;
}

export interface GatewaySyncRequestData {
  deployId?: string | undefined;
}

export interface GatewayExecutorRequestData {
  requestId: string;
  envId: string;
  appId: string;
  functionSlug: string;
  stepId?: string | undefined;
  requestPayload: Uint8Array;
}

export interface WorkerRequestAckData {
  requestId: string;
  appId: string;
  functionSlug: string;
  stepId?: string | undefined;
}

export interface SDKResponse {
  requestId: string;
  status: SDKResponseStatus;
  body: Uint8Array;
  noRetry: boolean;
  retryAfter?: string | undefined;
  sdkVersion: string;
  requestVersion: number;
}

/** Connection metadata */
export interface ConnMetadata {
  id: string;
  gatewayId: string;
  instanceId: string;
  groupId: string;
  status: ConnectionStatus;
  lastHeartbeatAt: Date | undefined;
  language: string;
  version: string;
  attributes: SystemAttributes | undefined;
}

export interface SystemAttributes {
  cpuCores: number;
  memBytes: number;
  os: string;
}

export interface ConnGroup {
  envId: string;
  appId: string;
  hash: string;
  conns: ConnMetadata[];
  syncId?: string | undefined;
  buildId?: string | undefined;
}

export interface StartResponse {
  gatewayEndpoint: string;
  gatewayGroup: string;
  sessionToken: string;
  syncToken: string;
}

export interface StartRequest {
  excludeGateways: string[];
}

function createBaseConnectMessage(): ConnectMessage {
  return { kind: 0, payload: new Uint8Array(0) };
}

export const ConnectMessage: MessageFns<ConnectMessage> = {
  encode(message: ConnectMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.kind !== 0) {
      writer.uint32(8).int32(message.kind);
    }
    if (message.payload.length !== 0) {
      writer.uint32(18).bytes(message.payload);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConnectMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnectMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.kind = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.payload = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConnectMessage {
    return {
      kind: isSet(object.kind) ? gatewayMessageTypeFromJSON(object.kind) : 0,
      payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(0),
    };
  },

  toJSON(message: ConnectMessage): unknown {
    const obj: any = {};
    if (message.kind !== 0) {
      obj.kind = gatewayMessageTypeToJSON(message.kind);
    }
    if (message.payload.length !== 0) {
      obj.payload = base64FromBytes(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConnectMessage>, I>>(base?: I): ConnectMessage {
    return ConnectMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConnectMessage>, I>>(object: I): ConnectMessage {
    const message = createBaseConnectMessage();
    message.kind = object.kind ?? 0;
    message.payload = object.payload ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSessionIdentifier(): SessionIdentifier {
  return { instanceId: "", connectionId: "", buildId: undefined };
}

export const SessionIdentifier: MessageFns<SessionIdentifier> = {
  encode(message: SessionIdentifier, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.instanceId !== "") {
      writer.uint32(10).string(message.instanceId);
    }
    if (message.connectionId !== "") {
      writer.uint32(18).string(message.connectionId);
    }
    if (message.buildId !== undefined) {
      writer.uint32(34).string(message.buildId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SessionIdentifier {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionIdentifier();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.instanceId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.connectionId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.buildId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionIdentifier {
    return {
      instanceId: isSet(object.instanceId) ? globalThis.String(object.instanceId) : "",
      connectionId: isSet(object.connectionId) ? globalThis.String(object.connectionId) : "",
      buildId: isSet(object.buildId) ? globalThis.String(object.buildId) : undefined,
    };
  },

  toJSON(message: SessionIdentifier): unknown {
    const obj: any = {};
    if (message.instanceId !== "") {
      obj.instanceId = message.instanceId;
    }
    if (message.connectionId !== "") {
      obj.connectionId = message.connectionId;
    }
    if (message.buildId !== undefined) {
      obj.buildId = message.buildId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SessionIdentifier>, I>>(base?: I): SessionIdentifier {
    return SessionIdentifier.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SessionIdentifier>, I>>(object: I): SessionIdentifier {
    const message = createBaseSessionIdentifier();
    message.instanceId = object.instanceId ?? "";
    message.connectionId = object.connectionId ?? "";
    message.buildId = object.buildId ?? undefined;
    return message;
  },
};

function createBaseSessionDetails(): SessionDetails {
  return { sessionId: undefined, functionHash: new Uint8Array(0) };
}

export const SessionDetails: MessageFns<SessionDetails> = {
  encode(message: SessionDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== undefined) {
      SessionIdentifier.encode(message.sessionId, writer.uint32(10).fork()).join();
    }
    if (message.functionHash.length !== 0) {
      writer.uint32(26).bytes(message.functionHash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SessionDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = SessionIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.functionHash = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionDetails {
    return {
      sessionId: isSet(object.sessionId) ? SessionIdentifier.fromJSON(object.sessionId) : undefined,
      functionHash: isSet(object.functionHash) ? bytesFromBase64(object.functionHash) : new Uint8Array(0),
    };
  },

  toJSON(message: SessionDetails): unknown {
    const obj: any = {};
    if (message.sessionId !== undefined) {
      obj.sessionId = SessionIdentifier.toJSON(message.sessionId);
    }
    if (message.functionHash.length !== 0) {
      obj.functionHash = base64FromBytes(message.functionHash);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SessionDetails>, I>>(base?: I): SessionDetails {
    return SessionDetails.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SessionDetails>, I>>(object: I): SessionDetails {
    const message = createBaseSessionDetails();
    message.sessionId = (object.sessionId !== undefined && object.sessionId !== null)
      ? SessionIdentifier.fromPartial(object.sessionId)
      : undefined;
    message.functionHash = object.functionHash ?? new Uint8Array(0);
    return message;
  },
};

function createBaseConfigDetails(): ConfigDetails {
  return { capabilities: new Uint8Array(0), functions: new Uint8Array(0) };
}

export const ConfigDetails: MessageFns<ConfigDetails> = {
  encode(message: ConfigDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.capabilities.length !== 0) {
      writer.uint32(10).bytes(message.capabilities);
    }
    if (message.functions.length !== 0) {
      writer.uint32(18).bytes(message.functions);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConfigDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfigDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.capabilities = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.functions = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConfigDetails {
    return {
      capabilities: isSet(object.capabilities) ? bytesFromBase64(object.capabilities) : new Uint8Array(0),
      functions: isSet(object.functions) ? bytesFromBase64(object.functions) : new Uint8Array(0),
    };
  },

  toJSON(message: ConfigDetails): unknown {
    const obj: any = {};
    if (message.capabilities.length !== 0) {
      obj.capabilities = base64FromBytes(message.capabilities);
    }
    if (message.functions.length !== 0) {
      obj.functions = base64FromBytes(message.functions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConfigDetails>, I>>(base?: I): ConfigDetails {
    return ConfigDetails.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConfigDetails>, I>>(object: I): ConfigDetails {
    const message = createBaseConfigDetails();
    message.capabilities = object.capabilities ?? new Uint8Array(0);
    message.functions = object.functions ?? new Uint8Array(0);
    return message;
  },
};

function createBaseAuthData(): AuthData {
  return { sessionToken: "", syncToken: "" };
}

export const AuthData: MessageFns<AuthData> = {
  encode(message: AuthData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionToken !== "") {
      writer.uint32(10).string(message.sessionToken);
    }
    if (message.syncToken !== "") {
      writer.uint32(18).string(message.syncToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.syncToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthData {
    return {
      sessionToken: isSet(object.sessionToken) ? globalThis.String(object.sessionToken) : "",
      syncToken: isSet(object.syncToken) ? globalThis.String(object.syncToken) : "",
    };
  },

  toJSON(message: AuthData): unknown {
    const obj: any = {};
    if (message.sessionToken !== "") {
      obj.sessionToken = message.sessionToken;
    }
    if (message.syncToken !== "") {
      obj.syncToken = message.syncToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthData>, I>>(base?: I): AuthData {
    return AuthData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthData>, I>>(object: I): AuthData {
    const message = createBaseAuthData();
    message.sessionToken = object.sessionToken ?? "";
    message.syncToken = object.syncToken ?? "";
    return message;
  },
};

function createBaseWorkerConnectRequestData(): WorkerConnectRequestData {
  return {
    sessionId: undefined,
    authData: undefined,
    appName: "",
    config: undefined,
    workerManualReadinessAck: false,
    systemAttributes: undefined,
    environment: undefined,
    framework: "",
    platform: undefined,
    sdkVersion: "",
    sdkLanguage: "",
    startedAt: undefined,
  };
}

export const WorkerConnectRequestData: MessageFns<WorkerConnectRequestData> = {
  encode(message: WorkerConnectRequestData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== undefined) {
      SessionIdentifier.encode(message.sessionId, writer.uint32(10).fork()).join();
    }
    if (message.authData !== undefined) {
      AuthData.encode(message.authData, writer.uint32(18).fork()).join();
    }
    if (message.appName !== "") {
      writer.uint32(26).string(message.appName);
    }
    if (message.config !== undefined) {
      ConfigDetails.encode(message.config, writer.uint32(34).fork()).join();
    }
    if (message.workerManualReadinessAck !== false) {
      writer.uint32(40).bool(message.workerManualReadinessAck);
    }
    if (message.systemAttributes !== undefined) {
      SystemAttributes.encode(message.systemAttributes, writer.uint32(50).fork()).join();
    }
    if (message.environment !== undefined) {
      writer.uint32(58).string(message.environment);
    }
    if (message.framework !== "") {
      writer.uint32(66).string(message.framework);
    }
    if (message.platform !== undefined) {
      writer.uint32(74).string(message.platform);
    }
    if (message.sdkVersion !== "") {
      writer.uint32(82).string(message.sdkVersion);
    }
    if (message.sdkLanguage !== "") {
      writer.uint32(90).string(message.sdkLanguage);
    }
    if (message.startedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.startedAt), writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkerConnectRequestData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkerConnectRequestData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = SessionIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.authData = AuthData.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.appName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.config = ConfigDetails.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.workerManualReadinessAck = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.systemAttributes = SystemAttributes.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.environment = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.framework = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.platform = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.sdkVersion = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.sdkLanguage = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.startedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkerConnectRequestData {
    return {
      sessionId: isSet(object.sessionId) ? SessionIdentifier.fromJSON(object.sessionId) : undefined,
      authData: isSet(object.authData) ? AuthData.fromJSON(object.authData) : undefined,
      appName: isSet(object.appName) ? globalThis.String(object.appName) : "",
      config: isSet(object.config) ? ConfigDetails.fromJSON(object.config) : undefined,
      workerManualReadinessAck: isSet(object.workerManualReadinessAck)
        ? globalThis.Boolean(object.workerManualReadinessAck)
        : false,
      systemAttributes: isSet(object.systemAttributes) ? SystemAttributes.fromJSON(object.systemAttributes) : undefined,
      environment: isSet(object.environment) ? globalThis.String(object.environment) : undefined,
      framework: isSet(object.framework) ? globalThis.String(object.framework) : "",
      platform: isSet(object.platform) ? globalThis.String(object.platform) : undefined,
      sdkVersion: isSet(object.sdkVersion) ? globalThis.String(object.sdkVersion) : "",
      sdkLanguage: isSet(object.sdkLanguage) ? globalThis.String(object.sdkLanguage) : "",
      startedAt: isSet(object.startedAt) ? fromJsonTimestamp(object.startedAt) : undefined,
    };
  },

  toJSON(message: WorkerConnectRequestData): unknown {
    const obj: any = {};
    if (message.sessionId !== undefined) {
      obj.sessionId = SessionIdentifier.toJSON(message.sessionId);
    }
    if (message.authData !== undefined) {
      obj.authData = AuthData.toJSON(message.authData);
    }
    if (message.appName !== "") {
      obj.appName = message.appName;
    }
    if (message.config !== undefined) {
      obj.config = ConfigDetails.toJSON(message.config);
    }
    if (message.workerManualReadinessAck !== false) {
      obj.workerManualReadinessAck = message.workerManualReadinessAck;
    }
    if (message.systemAttributes !== undefined) {
      obj.systemAttributes = SystemAttributes.toJSON(message.systemAttributes);
    }
    if (message.environment !== undefined) {
      obj.environment = message.environment;
    }
    if (message.framework !== "") {
      obj.framework = message.framework;
    }
    if (message.platform !== undefined) {
      obj.platform = message.platform;
    }
    if (message.sdkVersion !== "") {
      obj.sdkVersion = message.sdkVersion;
    }
    if (message.sdkLanguage !== "") {
      obj.sdkLanguage = message.sdkLanguage;
    }
    if (message.startedAt !== undefined) {
      obj.startedAt = message.startedAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorkerConnectRequestData>, I>>(base?: I): WorkerConnectRequestData {
    return WorkerConnectRequestData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorkerConnectRequestData>, I>>(object: I): WorkerConnectRequestData {
    const message = createBaseWorkerConnectRequestData();
    message.sessionId = (object.sessionId !== undefined && object.sessionId !== null)
      ? SessionIdentifier.fromPartial(object.sessionId)
      : undefined;
    message.authData = (object.authData !== undefined && object.authData !== null)
      ? AuthData.fromPartial(object.authData)
      : undefined;
    message.appName = object.appName ?? "";
    message.config = (object.config !== undefined && object.config !== null)
      ? ConfigDetails.fromPartial(object.config)
      : undefined;
    message.workerManualReadinessAck = object.workerManualReadinessAck ?? false;
    message.systemAttributes = (object.systemAttributes !== undefined && object.systemAttributes !== null)
      ? SystemAttributes.fromPartial(object.systemAttributes)
      : undefined;
    message.environment = object.environment ?? undefined;
    message.framework = object.framework ?? "";
    message.platform = object.platform ?? undefined;
    message.sdkVersion = object.sdkVersion ?? "";
    message.sdkLanguage = object.sdkLanguage ?? "";
    message.startedAt = object.startedAt ?? undefined;
    return message;
  },
};

function createBaseGatewaySyncRequestData(): GatewaySyncRequestData {
  return { deployId: undefined };
}

export const GatewaySyncRequestData: MessageFns<GatewaySyncRequestData> = {
  encode(message: GatewaySyncRequestData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.deployId !== undefined) {
      writer.uint32(10).string(message.deployId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GatewaySyncRequestData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGatewaySyncRequestData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.deployId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GatewaySyncRequestData {
    return { deployId: isSet(object.deployId) ? globalThis.String(object.deployId) : undefined };
  },

  toJSON(message: GatewaySyncRequestData): unknown {
    const obj: any = {};
    if (message.deployId !== undefined) {
      obj.deployId = message.deployId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GatewaySyncRequestData>, I>>(base?: I): GatewaySyncRequestData {
    return GatewaySyncRequestData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GatewaySyncRequestData>, I>>(object: I): GatewaySyncRequestData {
    const message = createBaseGatewaySyncRequestData();
    message.deployId = object.deployId ?? undefined;
    return message;
  },
};

function createBaseGatewayExecutorRequestData(): GatewayExecutorRequestData {
  return {
    requestId: "",
    envId: "",
    appId: "",
    functionSlug: "",
    stepId: undefined,
    requestPayload: new Uint8Array(0),
  };
}

export const GatewayExecutorRequestData: MessageFns<GatewayExecutorRequestData> = {
  encode(message: GatewayExecutorRequestData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.envId !== "") {
      writer.uint32(18).string(message.envId);
    }
    if (message.appId !== "") {
      writer.uint32(26).string(message.appId);
    }
    if (message.functionSlug !== "") {
      writer.uint32(34).string(message.functionSlug);
    }
    if (message.stepId !== undefined) {
      writer.uint32(42).string(message.stepId);
    }
    if (message.requestPayload.length !== 0) {
      writer.uint32(50).bytes(message.requestPayload);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GatewayExecutorRequestData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGatewayExecutorRequestData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.envId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.appId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.functionSlug = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.stepId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.requestPayload = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GatewayExecutorRequestData {
    return {
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      envId: isSet(object.envId) ? globalThis.String(object.envId) : "",
      appId: isSet(object.appId) ? globalThis.String(object.appId) : "",
      functionSlug: isSet(object.functionSlug) ? globalThis.String(object.functionSlug) : "",
      stepId: isSet(object.stepId) ? globalThis.String(object.stepId) : undefined,
      requestPayload: isSet(object.requestPayload) ? bytesFromBase64(object.requestPayload) : new Uint8Array(0),
    };
  },

  toJSON(message: GatewayExecutorRequestData): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.envId !== "") {
      obj.envId = message.envId;
    }
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    if (message.functionSlug !== "") {
      obj.functionSlug = message.functionSlug;
    }
    if (message.stepId !== undefined) {
      obj.stepId = message.stepId;
    }
    if (message.requestPayload.length !== 0) {
      obj.requestPayload = base64FromBytes(message.requestPayload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GatewayExecutorRequestData>, I>>(base?: I): GatewayExecutorRequestData {
    return GatewayExecutorRequestData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GatewayExecutorRequestData>, I>>(object: I): GatewayExecutorRequestData {
    const message = createBaseGatewayExecutorRequestData();
    message.requestId = object.requestId ?? "";
    message.envId = object.envId ?? "";
    message.appId = object.appId ?? "";
    message.functionSlug = object.functionSlug ?? "";
    message.stepId = object.stepId ?? undefined;
    message.requestPayload = object.requestPayload ?? new Uint8Array(0);
    return message;
  },
};

function createBaseWorkerRequestAckData(): WorkerRequestAckData {
  return { requestId: "", appId: "", functionSlug: "", stepId: undefined };
}

export const WorkerRequestAckData: MessageFns<WorkerRequestAckData> = {
  encode(message: WorkerRequestAckData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.appId !== "") {
      writer.uint32(18).string(message.appId);
    }
    if (message.functionSlug !== "") {
      writer.uint32(26).string(message.functionSlug);
    }
    if (message.stepId !== undefined) {
      writer.uint32(34).string(message.stepId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkerRequestAckData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkerRequestAckData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.appId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.functionSlug = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.stepId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkerRequestAckData {
    return {
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      appId: isSet(object.appId) ? globalThis.String(object.appId) : "",
      functionSlug: isSet(object.functionSlug) ? globalThis.String(object.functionSlug) : "",
      stepId: isSet(object.stepId) ? globalThis.String(object.stepId) : undefined,
    };
  },

  toJSON(message: WorkerRequestAckData): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    if (message.functionSlug !== "") {
      obj.functionSlug = message.functionSlug;
    }
    if (message.stepId !== undefined) {
      obj.stepId = message.stepId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorkerRequestAckData>, I>>(base?: I): WorkerRequestAckData {
    return WorkerRequestAckData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorkerRequestAckData>, I>>(object: I): WorkerRequestAckData {
    const message = createBaseWorkerRequestAckData();
    message.requestId = object.requestId ?? "";
    message.appId = object.appId ?? "";
    message.functionSlug = object.functionSlug ?? "";
    message.stepId = object.stepId ?? undefined;
    return message;
  },
};

function createBaseSDKResponse(): SDKResponse {
  return {
    requestId: "",
    status: 0,
    body: new Uint8Array(0),
    noRetry: false,
    retryAfter: undefined,
    sdkVersion: "",
    requestVersion: 0,
  };
}

export const SDKResponse: MessageFns<SDKResponse> = {
  encode(message: SDKResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (message.body.length !== 0) {
      writer.uint32(26).bytes(message.body);
    }
    if (message.noRetry !== false) {
      writer.uint32(32).bool(message.noRetry);
    }
    if (message.retryAfter !== undefined) {
      writer.uint32(42).string(message.retryAfter);
    }
    if (message.sdkVersion !== "") {
      writer.uint32(50).string(message.sdkVersion);
    }
    if (message.requestVersion !== 0) {
      writer.uint32(56).uint32(message.requestVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SDKResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSDKResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.body = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.noRetry = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.retryAfter = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.sdkVersion = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.requestVersion = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SDKResponse {
    return {
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      status: isSet(object.status) ? sDKResponseStatusFromJSON(object.status) : 0,
      body: isSet(object.body) ? bytesFromBase64(object.body) : new Uint8Array(0),
      noRetry: isSet(object.noRetry) ? globalThis.Boolean(object.noRetry) : false,
      retryAfter: isSet(object.retryAfter) ? globalThis.String(object.retryAfter) : undefined,
      sdkVersion: isSet(object.sdkVersion) ? globalThis.String(object.sdkVersion) : "",
      requestVersion: isSet(object.requestVersion) ? globalThis.Number(object.requestVersion) : 0,
    };
  },

  toJSON(message: SDKResponse): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.status !== 0) {
      obj.status = sDKResponseStatusToJSON(message.status);
    }
    if (message.body.length !== 0) {
      obj.body = base64FromBytes(message.body);
    }
    if (message.noRetry !== false) {
      obj.noRetry = message.noRetry;
    }
    if (message.retryAfter !== undefined) {
      obj.retryAfter = message.retryAfter;
    }
    if (message.sdkVersion !== "") {
      obj.sdkVersion = message.sdkVersion;
    }
    if (message.requestVersion !== 0) {
      obj.requestVersion = Math.round(message.requestVersion);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SDKResponse>, I>>(base?: I): SDKResponse {
    return SDKResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SDKResponse>, I>>(object: I): SDKResponse {
    const message = createBaseSDKResponse();
    message.requestId = object.requestId ?? "";
    message.status = object.status ?? 0;
    message.body = object.body ?? new Uint8Array(0);
    message.noRetry = object.noRetry ?? false;
    message.retryAfter = object.retryAfter ?? undefined;
    message.sdkVersion = object.sdkVersion ?? "";
    message.requestVersion = object.requestVersion ?? 0;
    return message;
  },
};

function createBaseConnMetadata(): ConnMetadata {
  return {
    id: "",
    gatewayId: "",
    instanceId: "",
    groupId: "",
    status: 0,
    lastHeartbeatAt: undefined,
    language: "",
    version: "",
    attributes: undefined,
  };
}

export const ConnMetadata: MessageFns<ConnMetadata> = {
  encode(message: ConnMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.gatewayId !== "") {
      writer.uint32(18).string(message.gatewayId);
    }
    if (message.instanceId !== "") {
      writer.uint32(26).string(message.instanceId);
    }
    if (message.groupId !== "") {
      writer.uint32(34).string(message.groupId);
    }
    if (message.status !== 0) {
      writer.uint32(40).int32(message.status);
    }
    if (message.lastHeartbeatAt !== undefined) {
      Timestamp.encode(toTimestamp(message.lastHeartbeatAt), writer.uint32(50).fork()).join();
    }
    if (message.language !== "") {
      writer.uint32(58).string(message.language);
    }
    if (message.version !== "") {
      writer.uint32(66).string(message.version);
    }
    if (message.attributes !== undefined) {
      SystemAttributes.encode(message.attributes, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConnMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.gatewayId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.instanceId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.groupId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.lastHeartbeatAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.language = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.attributes = SystemAttributes.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConnMetadata {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      gatewayId: isSet(object.gatewayId) ? globalThis.String(object.gatewayId) : "",
      instanceId: isSet(object.instanceId) ? globalThis.String(object.instanceId) : "",
      groupId: isSet(object.groupId) ? globalThis.String(object.groupId) : "",
      status: isSet(object.status) ? connectionStatusFromJSON(object.status) : 0,
      lastHeartbeatAt: isSet(object.lastHeartbeatAt) ? fromJsonTimestamp(object.lastHeartbeatAt) : undefined,
      language: isSet(object.language) ? globalThis.String(object.language) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      attributes: isSet(object.attributes) ? SystemAttributes.fromJSON(object.attributes) : undefined,
    };
  },

  toJSON(message: ConnMetadata): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.gatewayId !== "") {
      obj.gatewayId = message.gatewayId;
    }
    if (message.instanceId !== "") {
      obj.instanceId = message.instanceId;
    }
    if (message.groupId !== "") {
      obj.groupId = message.groupId;
    }
    if (message.status !== 0) {
      obj.status = connectionStatusToJSON(message.status);
    }
    if (message.lastHeartbeatAt !== undefined) {
      obj.lastHeartbeatAt = message.lastHeartbeatAt.toISOString();
    }
    if (message.language !== "") {
      obj.language = message.language;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.attributes !== undefined) {
      obj.attributes = SystemAttributes.toJSON(message.attributes);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConnMetadata>, I>>(base?: I): ConnMetadata {
    return ConnMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConnMetadata>, I>>(object: I): ConnMetadata {
    const message = createBaseConnMetadata();
    message.id = object.id ?? "";
    message.gatewayId = object.gatewayId ?? "";
    message.instanceId = object.instanceId ?? "";
    message.groupId = object.groupId ?? "";
    message.status = object.status ?? 0;
    message.lastHeartbeatAt = object.lastHeartbeatAt ?? undefined;
    message.language = object.language ?? "";
    message.version = object.version ?? "";
    message.attributes = (object.attributes !== undefined && object.attributes !== null)
      ? SystemAttributes.fromPartial(object.attributes)
      : undefined;
    return message;
  },
};

function createBaseSystemAttributes(): SystemAttributes {
  return { cpuCores: 0, memBytes: 0, os: "" };
}

export const SystemAttributes: MessageFns<SystemAttributes> = {
  encode(message: SystemAttributes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cpuCores !== 0) {
      writer.uint32(8).int32(message.cpuCores);
    }
    if (message.memBytes !== 0) {
      writer.uint32(16).int64(message.memBytes);
    }
    if (message.os !== "") {
      writer.uint32(26).string(message.os);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SystemAttributes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSystemAttributes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.cpuCores = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.memBytes = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.os = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SystemAttributes {
    return {
      cpuCores: isSet(object.cpuCores) ? globalThis.Number(object.cpuCores) : 0,
      memBytes: isSet(object.memBytes) ? globalThis.Number(object.memBytes) : 0,
      os: isSet(object.os) ? globalThis.String(object.os) : "",
    };
  },

  toJSON(message: SystemAttributes): unknown {
    const obj: any = {};
    if (message.cpuCores !== 0) {
      obj.cpuCores = Math.round(message.cpuCores);
    }
    if (message.memBytes !== 0) {
      obj.memBytes = Math.round(message.memBytes);
    }
    if (message.os !== "") {
      obj.os = message.os;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SystemAttributes>, I>>(base?: I): SystemAttributes {
    return SystemAttributes.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SystemAttributes>, I>>(object: I): SystemAttributes {
    const message = createBaseSystemAttributes();
    message.cpuCores = object.cpuCores ?? 0;
    message.memBytes = object.memBytes ?? 0;
    message.os = object.os ?? "";
    return message;
  },
};

function createBaseConnGroup(): ConnGroup {
  return { envId: "", appId: "", hash: "", conns: [], syncId: undefined, buildId: undefined };
}

export const ConnGroup: MessageFns<ConnGroup> = {
  encode(message: ConnGroup, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.envId !== "") {
      writer.uint32(10).string(message.envId);
    }
    if (message.appId !== "") {
      writer.uint32(18).string(message.appId);
    }
    if (message.hash !== "") {
      writer.uint32(26).string(message.hash);
    }
    for (const v of message.conns) {
      ConnMetadata.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.syncId !== undefined) {
      writer.uint32(42).string(message.syncId);
    }
    if (message.buildId !== undefined) {
      writer.uint32(50).string(message.buildId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConnGroup {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.envId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.appId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.hash = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.conns.push(ConnMetadata.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.syncId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.buildId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConnGroup {
    return {
      envId: isSet(object.envId) ? globalThis.String(object.envId) : "",
      appId: isSet(object.appId) ? globalThis.String(object.appId) : "",
      hash: isSet(object.hash) ? globalThis.String(object.hash) : "",
      conns: globalThis.Array.isArray(object?.conns) ? object.conns.map((e: any) => ConnMetadata.fromJSON(e)) : [],
      syncId: isSet(object.syncId) ? globalThis.String(object.syncId) : undefined,
      buildId: isSet(object.buildId) ? globalThis.String(object.buildId) : undefined,
    };
  },

  toJSON(message: ConnGroup): unknown {
    const obj: any = {};
    if (message.envId !== "") {
      obj.envId = message.envId;
    }
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    if (message.hash !== "") {
      obj.hash = message.hash;
    }
    if (message.conns?.length) {
      obj.conns = message.conns.map((e) => ConnMetadata.toJSON(e));
    }
    if (message.syncId !== undefined) {
      obj.syncId = message.syncId;
    }
    if (message.buildId !== undefined) {
      obj.buildId = message.buildId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConnGroup>, I>>(base?: I): ConnGroup {
    return ConnGroup.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConnGroup>, I>>(object: I): ConnGroup {
    const message = createBaseConnGroup();
    message.envId = object.envId ?? "";
    message.appId = object.appId ?? "";
    message.hash = object.hash ?? "";
    message.conns = object.conns?.map((e) => ConnMetadata.fromPartial(e)) || [];
    message.syncId = object.syncId ?? undefined;
    message.buildId = object.buildId ?? undefined;
    return message;
  },
};

function createBaseStartResponse(): StartResponse {
  return { gatewayEndpoint: "", gatewayGroup: "", sessionToken: "", syncToken: "" };
}

export const StartResponse: MessageFns<StartResponse> = {
  encode(message: StartResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gatewayEndpoint !== "") {
      writer.uint32(10).string(message.gatewayEndpoint);
    }
    if (message.gatewayGroup !== "") {
      writer.uint32(18).string(message.gatewayGroup);
    }
    if (message.sessionToken !== "") {
      writer.uint32(26).string(message.sessionToken);
    }
    if (message.syncToken !== "") {
      writer.uint32(34).string(message.syncToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.gatewayEndpoint = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.gatewayGroup = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sessionToken = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.syncToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartResponse {
    return {
      gatewayEndpoint: isSet(object.gatewayEndpoint) ? globalThis.String(object.gatewayEndpoint) : "",
      gatewayGroup: isSet(object.gatewayGroup) ? globalThis.String(object.gatewayGroup) : "",
      sessionToken: isSet(object.sessionToken) ? globalThis.String(object.sessionToken) : "",
      syncToken: isSet(object.syncToken) ? globalThis.String(object.syncToken) : "",
    };
  },

  toJSON(message: StartResponse): unknown {
    const obj: any = {};
    if (message.gatewayEndpoint !== "") {
      obj.gatewayEndpoint = message.gatewayEndpoint;
    }
    if (message.gatewayGroup !== "") {
      obj.gatewayGroup = message.gatewayGroup;
    }
    if (message.sessionToken !== "") {
      obj.sessionToken = message.sessionToken;
    }
    if (message.syncToken !== "") {
      obj.syncToken = message.syncToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StartResponse>, I>>(base?: I): StartResponse {
    return StartResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StartResponse>, I>>(object: I): StartResponse {
    const message = createBaseStartResponse();
    message.gatewayEndpoint = object.gatewayEndpoint ?? "";
    message.gatewayGroup = object.gatewayGroup ?? "";
    message.sessionToken = object.sessionToken ?? "";
    message.syncToken = object.syncToken ?? "";
    return message;
  },
};

function createBaseStartRequest(): StartRequest {
  return { excludeGateways: [] };
}

export const StartRequest: MessageFns<StartRequest> = {
  encode(message: StartRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.excludeGateways) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.excludeGateways.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartRequest {
    return {
      excludeGateways: globalThis.Array.isArray(object?.excludeGateways)
        ? object.excludeGateways.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: StartRequest): unknown {
    const obj: any = {};
    if (message.excludeGateways?.length) {
      obj.excludeGateways = message.excludeGateways;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StartRequest>, I>>(base?: I): StartRequest {
    return StartRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StartRequest>, I>>(object: I): StartRequest {
    const message = createBaseStartRequest();
    message.excludeGateways = object.excludeGateways?.map((e) => e) || [];
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
